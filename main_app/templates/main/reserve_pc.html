{% extends 'base.html' %}
{% load template_filters %}
{% load math_filters %}
{% load static %}

{% block title %}PC List{% endblock %}

{% block links %}
<link rel="stylesheet" href="{% static 'css/booking.css' %}?v=15">
{% endblock %}

{% block extra_head %}
<script>
// Custom Alert Function - Shows a styled modal instead of native alert
window.showCustomAlert = function(message, currentTime) {
  var modal = document.getElementById('customAlertModal');
  var messageEl = document.getElementById('customAlertMessage');
  var timeEl = document.getElementById('customAlertTime');
  
  if (modal && messageEl && timeEl) {
    messageEl.textContent = message;
    if (currentTime) {
      timeEl.textContent = 'Current time: ' + currentTime;
      timeEl.style.display = 'block';
    } else {
      timeEl.style.display = 'none';
    }
    
    // Show modal using Bootstrap
    if (typeof bootstrap !== 'undefined') {
      var modalInstance = new bootstrap.Modal(modal);
      modalInstance.show();
    } else {
      // Fallback if Bootstrap is not available
      modal.style.display = 'block';
      modal.classList.add('show');
      document.body.classList.add('modal-open');
    }
  } else {
    // Fallback to native alert if modal elements not found
    alert(message + (currentTime ? '\n\nCurrent time: ' + currentTime : ''));
  }
};

// Define showPCStatus immediately so it's available for inline onclick handlers
// This must be defined before the HTML that uses it
window.showPCStatus = function(pcId, button) {
  console.log('Checking PC status:', pcId);
  
  // Get PC status from button data attributes
  const pcStatus = button.getAttribute('data-pc-status');
  const pcCondition = button.getAttribute('data-pc-condition');
  const pcBookingStatus = button.getAttribute('data-booking-status');
  const pcName = button.getAttribute('data-pc-name');
  
  // Get modal elements
  const modal = document.getElementById('pcStatusModal');
  const modalLabel = document.getElementById('pcStatusModalLabel');
  const modalHeader = document.getElementById('pcStatusModalHeader');
  const modalBody = document.getElementById('pcStatusContent');
  const endSessionBtn = document.getElementById('pc-status-end-session-btn');
  
  // Check if modal elements exist
  if (!modal || !modalLabel || !modalHeader || !modalBody) {
    console.error('PC Status modal elements not found');
    alert('Error: PC Status modal not found. Please refresh the page.');
    return false;
  }
  
  // Hide end session button by default
  if (endSessionBtn) {
    endSessionBtn.style.display = 'none';
    endSessionBtn.setAttribute('data-booking-id', '');
  }
  
  // Check if PC is in repair
  if (pcCondition === 'repair') {
    modalLabel.innerHTML = '<i class="fa-solid fa-tools"></i> PC In Repair';
    modalHeader.className = 'modal-header bg-danger text-white';
    modalBody.innerHTML = `
      <div class="mb-3">
        <i class="fa-solid fa-tools" style="font-size: 3rem; color: #dc3545;"></i>
      </div>
      <h4>PC ${pcName}</h4>
      <p class="text-muted">This PC is currently in repair and not available for reservation until maintenance is complete.</p>
    `;
    if (modal && typeof bootstrap !== 'undefined') {
      const bsModal = new bootstrap.Modal(modal);
      bsModal.show();
    }
    return false;
  }
  
  // Check if PC is offline/disconnected
  if (pcStatus === 'disconnected') {
    modalLabel.innerHTML = '<i class="fa-solid fa-plug"></i> PC Offline';
    modalHeader.className = 'modal-header bg-secondary text-white';
    modalBody.innerHTML = `
      <div class="mb-3">
        <i class="fa-solid fa-plug" style="font-size: 3rem; color: #6c757d;"></i>
      </div>
      <h4>PC ${pcName}</h4>
      <p class="text-muted">This PC is currently offline and not available for reservation until it is connected.</p>
    `;
    if (modal && typeof bootstrap !== 'undefined') {
      const bsModal = new bootstrap.Modal(modal);
      bsModal.show();
    }
    return false;
  }
  
  // Fetch booking information for this PC
  fetch(`/ajax/get-pc-booking/${pcId}/`)
    .then(response => response.json())
    .then(data => {
      console.log('PC booking data:', data);
      
      // Update button's data-booking-status if it's different
      if (data.booking_status && data.booking_status !== pcBookingStatus) {
        button.setAttribute('data-booking-status', data.booking_status);
        // Update button class if needed
        button.classList.remove('pc-used', 'pc-queue', 'pc-available');
        if (data.booking_status === 'in_use') {
          button.classList.add('pc-used');
        } else if (data.booking_status === 'in_queue') {
          button.classList.add('pc-queue');
        } else {
          button.classList.add('pc-available');
        }
      }
      
      // Populate modal based on status
      if (data.booking_status === 'in_queue') {
        const isCurrentUser = data.is_current_user || false;
        modalLabel.innerHTML = '<i class="fa-solid fa-hourglass-half"></i> PC In Queue';
        modalHeader.className = 'modal-header bg-warning text-dark';
        modalBody.innerHTML = `
          <div class="mb-3">
            <i class="fa-solid fa-hourglass-half" style="font-size: 3rem; color: #ffc107;"></i>
          </div>
          <h4>PC ${data.pc_name}</h4>
          <p class="text-muted">This PC is waiting for staff approval.</p>
          <p><strong>Request made at:</strong><br>${data.created_time || 'Unknown'}</p>
        `;
        // Show "End Session" button if current user has this PC in queue
        if (endSessionBtn && isCurrentUser && data.booking_id) {
          endSessionBtn.setAttribute('data-booking-id', data.booking_id);
          window.currentBookingId = data.booking_id;
          endSessionBtn.style.display = 'block';
          // Set onclick handler
          endSessionBtn.onclick = function(e) {
            if (e) {
              e.preventDefault();
              e.stopPropagation();
            }
            return window.handleEndSession(e);
          };
          console.log('End Session button shown for current user (in queue), booking_id:', data.booking_id);
        } else if (endSessionBtn) {
          endSessionBtn.style.display = 'none';
        }
      } else if (data.booking_status === 'in_use') {
        const timeLeft = data.time_remaining || 'Unknown';
        const userName = data.user || 'Another student';
        const isCurrentUser = data.is_current_user || false;
        modalLabel.innerHTML = '<i class="fa-solid fa-user-clock"></i> PC In Use';
        modalHeader.className = 'modal-header bg-info text-white';
        modalBody.innerHTML = `
          <div class="mb-3">
            <i class="fa-solid fa-user-clock" style="font-size: 3rem; color: #0dcaf0;"></i>
          </div>
          <h4>PC ${data.pc_name}</h4>
          <p class="text-muted">This PC is currently in use by <strong>${userName}</strong>.</p>
          <div class="mt-3">
            <p><strong>Estimated time remaining:</strong></p>
            <h3 class="text-primary">${timeLeft}</h3>
          </div>
        `;
        
        // Show "End Session" button if current user is the one using this PC
        if (endSessionBtn && isCurrentUser && data.booking_id) {
          endSessionBtn.setAttribute('data-booking-id', data.booking_id);
          window.currentBookingId = data.booking_id;
          endSessionBtn.style.display = 'block';
          // Set onclick handler
          endSessionBtn.onclick = function(e) {
            if (e) {
              e.preventDefault();
              e.stopPropagation();
            }
            return window.handleEndSession(e);
          };
          console.log('End Session button shown for current user, booking_id:', data.booking_id);
        } else if (endSessionBtn) {
          endSessionBtn.style.display = 'none';
        }
      } else {
        modalLabel.innerHTML = '<i class="fa-solid fa-check-circle"></i> PC Available';
        modalHeader.className = 'modal-header bg-success text-white';
        modalBody.innerHTML = `
          <div class="mb-3">
            <i class="fa-solid fa-check-circle" style="font-size: 3rem; color: #198754;"></i>
          </div>
          <h4>PC ${data.pc_name}</h4>
          <p class="text-muted">This PC is available for reservation.</p>
        `;
        // Hide end session button for available PCs
        if (endSessionBtn) {
          endSessionBtn.style.display = 'none';
        }
      }
      
      // Show modal
      if (modal && typeof bootstrap !== 'undefined') {
        try {
          const bsModal = new bootstrap.Modal(modal);
          bsModal.show();
          console.log('PC Status modal shown');
        } catch (error) {
          console.error('Error showing PC Status modal:', error);
          alert('Error showing PC status. Please refresh the page.');
        }
      } else {
        console.error('Bootstrap not available or modal not found');
        alert('Error: Unable to show PC status. Please refresh the page.');
      }
    })
    .catch(error => {
      console.error('Error fetching PC status:', error);
      modalLabel.innerHTML = '<i class="fa-solid fa-exclamation-triangle"></i> Error';
      modalHeader.className = 'modal-header bg-danger text-white';
      modalBody.innerHTML = `
        <div class="mb-3">
          <i class="fa-solid fa-exclamation-triangle" style="font-size: 3rem; color: #dc3545;"></i>
        </div>
        <p class="text-danger">Unable to fetch PC status information.</p>
      `;
      if (modal && typeof bootstrap !== 'undefined') {
        const bsModal = new bootstrap.Modal(modal);
        bsModal.show();
      }
    });
  
  return false;
};

// Shared helper to show/hide selected PC indicator
window.updateSelectedPcIndicator = function(pcName) {
  var indicator = document.getElementById('selected-pc-indicator');
  var nameEl = document.getElementById('selected-pc-name');
  if (!indicator || !nameEl) {
    return;
  }

  if (pcName) {
    indicator.removeAttribute('hidden');
    indicator.style.display = 'flex';
    indicator.style.visibility = 'visible';
    nameEl.textContent = pcName;
  } else {
    indicator.setAttribute('hidden', 'true');
    indicator.style.display = 'none';
    indicator.style.visibility = 'hidden';
    nameEl.textContent = '';
  }
};

// Define handleEndSession immediately so it's available for showPCStatus
// This must be defined before the HTML that uses it
window.handleEndSession = function(e) {
  if (e) {
    e.preventDefault();
    e.stopPropagation();
  }
  
  // Try multiple sources for booking_id
  // First try to get from the button that was clicked
  var btn = e ? (e.target || e.currentTarget) : null;
  
  // If clicked element is the icon, get the parent button
  if (btn && (btn.tagName === 'I' || btn.tagName === 'SPAN')) {
    btn = btn.closest('button');
  }
  
  var bookingId = null;
  
  // Try to get booking_id from clicked button
  if (btn) {
    bookingId = btn.getAttribute('data-booking-id') || btn.dataset.bookingId;
  }
  
  // If not found, try window.currentBookingId
  if (!bookingId) {
    bookingId = window.currentBookingId;
  }
  
  // If still not found, try other buttons
  if (!bookingId) {
    var endSessionBtn = document.getElementById('end-session-btn');
    if (endSessionBtn) {
      bookingId = endSessionBtn.getAttribute('data-booking-id');
    }
  }
  
  if (!bookingId) {
    var pcStatusEndBtn = document.getElementById('pc-status-end-session-btn');
    if (pcStatusEndBtn) {
      bookingId = pcStatusEndBtn.getAttribute('data-booking-id');
    }
  }
  
  console.log('End session clicked');
  console.log('Current booking ID from window.currentBookingId:', window.currentBookingId);
  console.log('Current booking ID from button:', bookingId);
  console.log('Button element:', btn);
  
  if (!bookingId || bookingId === '' || bookingId === 'null' || bookingId === 'undefined') {
    console.error('Booking ID not found. All sources checked.');
    alert('Error: Booking ID not found. Please refresh the page and try again.');
    return false;
  }
  
  // Ensure bookingId is a string/number, not null/undefined
  bookingId = String(bookingId).trim();
  
  // Validate bookingId is a valid number
  if (!bookingId || isNaN(parseInt(bookingId))) {
    console.error('Invalid booking ID format:', bookingId);
    alert('Error: Invalid booking ID format. Please refresh the page and try again.');
    return false;
  }
  
  if (confirm('Are you sure you want to end your session early?')) {
    var url = '/ajax/end-session/' + bookingId + '/';
    console.log('Calling end session URL:', url);
    
    fetch(url, {
      method: 'POST',
      headers: {
        'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]')?.value || 
                      document.cookie.match(/csrftoken=([^;]+)/)?.[1] || '',
        'Content-Type': 'application/json'
      }
    })
    .then(response => {
      console.log('Response status:', response.status);
      if (!response.ok) {
        return response.text().then(text => {
          console.error('Error response:', text);
          throw new Error('HTTP error! status: ' + response.status + ' - ' + text);
        });
      }
      return response.json();
    })
    .then(data => {
      console.log('End session response:', data);
      if (data.success) {
        alert(data.message || 'Session ended successfully');
        // Close the modal if it's open
        var modal = bootstrap.Modal.getInstance(document.getElementById('mySessionModal'));
        if (modal) {
          modal.hide();
        }
        var pcStatusModal = bootstrap.Modal.getInstance(document.getElementById('pcStatusModal'));
        if (pcStatusModal) {
          pcStatusModal.hide();
        }
        location.reload();
      } else {
        alert('Error: ' + (data.error || data.message || 'Failed to end session'));
      }
    })
    .catch(error => {
      console.error('Error ending session:', error);
      alert('Error: Failed to end session. ' + error.message + '\nPlease check console for details.');
    });
  }
  return false;
};

// Define selectPCForReservation immediately so it's available for inline onclick handlers
// This must be defined before the HTML that uses it
window.selectPCForReservation = function(pcId, button) {
  console.log('PC clicked:', pcId);
  
  // Check if button is disabled - if so, prevent selection
  if (button.disabled || button.hasAttribute('disabled')) {
    console.warn('Button is disabled, ignoring click');
    return;
  }
  
  // Check if user has active individual PC booking (student booking)
  // If they have an active individual PC booking, block all new bookings
  if (window.__hasActiveBooking === true) {
    alert('You already have an active individual PC booking. Please wait for your current booking to end before booking another PC.');
    return;
  }
  
  // Note: We allow individual PC booking even if user has active faculty booking
  // Faculty booking doesn't block individual PC booking
  
  // Get PC status from button data attributes
  const pcStatus = button.getAttribute('data-pc-status');
  const pcCondition = button.getAttribute('data-pc-condition');
  const pcBookingStatus = button.getAttribute('data-booking-status');
  const pcName = button.getAttribute('data-pc-name');
  
  // Double-check if PC is in repair (safety check)
  if (pcCondition === 'repair') {
    alert(`PC ${pcName} is currently in repair.\n\nThis PC is not available for reservation until maintenance is complete.`);
    if (typeof window.updateSelectedPcIndicator === 'function') {
      window.updateSelectedPcIndicator(null);
    }
    button.disabled = true;
    button.style.pointerEvents = 'none';
    button.style.opacity = '0.6';
    return;
  }
  
  // Double-check if PC is offline/disconnected (safety check)
  if (pcStatus === 'disconnected') {
    alert(`PC ${pcName} is currently offline.\n\nThis PC is not available for reservation until it is connected.`);
    if (typeof window.updateSelectedPcIndicator === 'function') {
      window.updateSelectedPcIndicator(null);
    }
    button.disabled = true;
    button.style.pointerEvents = 'none';
    button.style.opacity = '0.6';
    return;
  }
  
  // Check if PC is already booked
  if (pcBookingStatus === 'in_use' || pcBookingStatus === 'in_queue') {
    alert(`PC ${pcName} is currently ${pcBookingStatus.replace('_', ' ')}.\n\nThis PC is not available for reservation.`);
    button.disabled = true;
    return;
  }
  
  // Toggle the selected class - handle both old and new button styles
  var isSelected;
  if (button.classList.contains('pc-button-modern')) {
    button.classList.toggle('selected');
    button.classList.toggle('pc-selected');
    isSelected = button.classList.contains('selected');
  } else {
    button.classList.toggle('text-success');
    isSelected = button.classList.contains('text-success');
  }
  
  // Set the hidden PC ID field
  var pcIdInput = document.getElementById('pc_id');
  if (pcIdInput) {
    pcIdInput.value = pcId;
  }
  
  // Toggle selected class and disable other PC buttons
  var allButtons = document.querySelectorAll('.pc-button-modern, .pc-button');
  allButtons.forEach(function(btn) {
    if (btn !== button) {
      btn.classList.remove('selected', 'pc-selected');
      if (isSelected) {
        btn.disabled = true;
      } else {
        // Only re-enable if user doesn't have active booking (student or faculty)
        if (!window.__hasActiveBooking && !window.__hasActiveFacultyBooking) {
          // Still check for repair/offline/booking status
          var pcCondition = btn.getAttribute('data-pc-condition');
          var pcStatus = btn.getAttribute('data-pc-status');
          var pcBookingStatus = btn.getAttribute('data-booking-status');
          if (pcCondition !== 'repair' && 
              pcStatus !== 'disconnected' &&
              pcBookingStatus !== 'in_use' &&
              pcBookingStatus !== 'in_queue') {
            btn.disabled = false;
          }
        }
      }
    } else {
      if (isSelected) {
        button.classList.add('selected', 'pc-selected');
      } else {
        button.classList.remove('selected', 'pc-selected');
      }
    }
  });
  
  // Show/hide pagination
  var pageNav = document.getElementById('page-nav');
  var paginationModern = document.querySelector('.pagination-modern');
  if (pageNav) {
    pageNav.hidden = isSelected;
  }
  if (paginationModern) {
    paginationModern.style.display = isSelected ? 'none' : 'flex';
  }
  
  // Show/hide Next button - only if PC is truly available
  var nextButton = document.querySelector('.reserve-next-button');
  if (nextButton) {
    // Keep button always visible; enable only if valid selection
    var isAvailable = pcBookingStatus !== 'in_use' &&
                      pcBookingStatus !== 'in_queue' &&
                      pcCondition !== 'repair' &&
                      pcStatus !== 'disconnected';
    var canProceed = isSelected && isAvailable;
    nextButton.disabled = !canProceed;
    if (canProceed) {
      nextButton.removeAttribute('aria-disabled');
    } else {
      nextButton.setAttribute('aria-disabled', 'true');
    }
    console.log('Next button state', { canProceed, isSelected, pcBookingStatus, pcCondition, pcStatus });
  } else {
    console.warn('Next button not found!');
  }
  
  // Show/hide Block button
  var blockButton = document.getElementById('block-button');
  if (blockButton) {
    blockButton.hidden = isSelected;
  }
  
  if (typeof window.updateSelectedPcIndicator === 'function') {
    window.updateSelectedPcIndicator(isSelected ? (pcName || `PC ${pcId}`) : null);
  }

  console.log('PC selection complete. Selected:', isSelected);
};

// Function to close modal and scroll to reservation container
// Define it in extra_head so it's available before the HTML that uses it
function closeModalAndScrollToReservation() {
  console.log('Cancel button clicked - closing modal and scrolling to reservation');
  // Close the PC selection modal
  var pcSelectionModal = document.getElementById('pcSelectionModal');
  if (pcSelectionModal && typeof bootstrap !== 'undefined') {
    var modalInstance = bootstrap.Modal.getInstance(pcSelectionModal);
    if (modalInstance) {
      modalInstance.hide();
    } else {
      // If no instance exists, create one and hide it
      var modal = new bootstrap.Modal(pcSelectionModal);
      modal.hide();
    }
  }
  
  // Wait for modal to close, then scroll to reservation container
  setTimeout(function() {
    var reservationContainer = document.querySelector('.mobile-reservation-container');
    if (reservationContainer) {
      reservationContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
      // Also ensure it's visible
      if (typeof window.ensureReservationBodyVisible === 'function') {
        window.ensureReservationBodyVisible();
      }
    }
  }, 300);
}

// Also assign to window for global access
window.closeModalAndScrollToReservation = closeModalAndScrollToReservation;

function closeModalAndScrollToReservationCard() {
  console.log('Back button clicked - closing modal and refreshing page');
  // Close the PC selection modal
  var pcSelectionModal = document.getElementById('pcSelectionModal');
  if (pcSelectionModal && typeof bootstrap !== 'undefined') {
    var modalInstance = bootstrap.Modal.getInstance(pcSelectionModal);
    if (modalInstance) {
      modalInstance.hide();
    } else {
      // If no instance exists, create one and hide it
      var modal = new bootstrap.Modal(pcSelectionModal);
      modal.hide();
    }
  }
  
  // Wait for modal to close, then refresh the page
  setTimeout(function() {
    location.reload();
  }, 300);
}

// Also assign to window for global access
window.closeModalAndScrollToReservationCard = closeModalAndScrollToReservationCard;

// Define validateStep1 early so it's available for onclick handlers
// This ensures the function exists before the button is rendered
window.validateStep1 = function validateStep1() {
  console.log('validateStep1 called');
  var course = document.getElementById('course');
  var block = document.getElementById('block');
  var college = document.getElementById('college');
  var dateStart = document.getElementById('dateStart');
  var dateEnd = document.getElementById('dateEnd');
  var numOfPc = document.getElementById('numOfPc');
  var custNumOfPc = document.getElementById('custNumOfPc');
  var customNumOfPc = document.getElementById('customNumOfPc'); // Visible input field
  
  // Get the form element
  var form = document.getElementById('facultyForm');
  var step1 = document.getElementById('step1');
  
  // Clear previous invalid states
  var allInputs = step1 ? step1.querySelectorAll('.form-control, .select') : [];
  allInputs.forEach(function(input) {
    input.classList.remove('is-invalid');
  });
  
  var errors = [];
  var firstInvalidField = null;
  
  // Validate Course (required)
  if (!course || !course.value.trim()) {
    errors.push('Please enter a course');
    if (course) {
      course.classList.add('is-invalid');
      if (!firstInvalidField) firstInvalidField = course;
    }
  } else {
    if (course) course.classList.remove('is-invalid');
  }
  
  // Validate Block (required)
  if (!block || !block.value.trim()) {
    errors.push('Please enter a block');
    if (block) {
      block.classList.add('is-invalid');
      if (!firstInvalidField) firstInvalidField = block;
    }
  } else {
    if (block) block.classList.remove('is-invalid');
  }
  
  // Validate College (required)
  if (!college || !college.value || college.value === '') {
    errors.push('Please select a college');
    if (college) {
      college.classList.add('is-invalid');
      if (!firstInvalidField) firstInvalidField = college;
    }
  } else {
    if (college) college.classList.remove('is-invalid');
  }
  
  // Validate Start Date (required)
  if (!dateStart || !dateStart.value) {
    errors.push('Please select a start date and time');
    if (dateStart) {
      dateStart.classList.add('is-invalid');
      if (!firstInvalidField) firstInvalidField = dateStart;
    }
  } else {
    if (dateStart) dateStart.classList.remove('is-invalid');
  }
  
  // Validate End Date (required)
  if (!dateEnd || !dateEnd.value) {
    errors.push('Please select an end date and time');
    if (dateEnd) {
      dateEnd.classList.add('is-invalid');
      if (!firstInvalidField) firstInvalidField = dateEnd;
    }
  } else {
    if (dateEnd) dateEnd.classList.remove('is-invalid');
  }
  
  // Validate date range (end must be after start)
  if (dateStart && dateStart.value && dateEnd && dateEnd.value) {
    var startDate = new Date(dateStart.value);
    var endDate = new Date(dateEnd.value);
    if (endDate <= startDate) {
      errors.push('End date must be after start date');
      if (dateEnd) {
        dateEnd.classList.add('is-invalid');
        if (!firstInvalidField) firstInvalidField = dateEnd;
      }
    }
  }
  
  // Check if PC quantity is selected (required)
  // Check visible customNumOfPc field first, then hidden fields
  var pcQty = 0;
  if (customNumOfPc && parseInt(customNumOfPc.value) > 0) {
    pcQty = parseInt(customNumOfPc.value);
    // Sync to hidden field if needed
    if (custNumOfPc) {
      custNumOfPc.value = pcQty;
    }
  } else if (custNumOfPc && parseInt(custNumOfPc.value) > 0) {
    pcQty = parseInt(custNumOfPc.value);
  } else if (numOfPc && parseInt(numOfPc.value) > 0) {
    pcQty = parseInt(numOfPc.value);
  }
  
  if (pcQty <= 0) {
    errors.push('Please select the number of PCs needed from the PC selection modal');
  } else if (pcQty < 2) {
    // Minimum is 2 PCs
    errors.push('Minimum booking is 2 PCs. Please add more PCs to continue.');
    // Show popup alert
    alert('Minimum booking is 2 PCs. Please add more PCs to continue.');
    // Focus on the PC input field
    if (customNumOfPc) {
      customNumOfPc.focus();
      customNumOfPc.select();
    }
  }
  
  // If there are errors, show them and focus on first invalid field
  if (errors.length > 0) {
    // Scroll to first invalid field
    if (firstInvalidField) {
      firstInvalidField.scrollIntoView({ behavior: 'smooth', block: 'center' });
      setTimeout(function() {
        firstInvalidField.focus();
      }, 300);
    }
    
    // Show error message
    var errorMessage = 'Please fix the following errors:\n\n' + errors.join('\n');
    alert(errorMessage);
    return false;
  }
  
  // All validations passed, advance to next step
  console.log('All validations passed, advancing to step2');
  if (typeof window.advanceStep === 'function') {
    console.log('Calling window.advanceStep');
    window.advanceStep('step1', 'step2');
  } else if (typeof advanceStep === 'function') {
    console.log('Calling advanceStep');
    advanceStep('step1', 'step2');
  } else {
    console.error('advanceStep function not found!');
    // Fallback: manually toggle steps
    var step1Div = document.getElementById('step1');
    var step2Div = document.getElementById('step2');
    if (step1Div) step1Div.classList.remove('active');
    if (step2Div) step2Div.classList.add('active');
  }
  return false;
};

// Initialize MAX_AVAILABLE_PCS early from template value
window.MAX_AVAILABLE_PCS = {{ available_count|default:total_pc }};

// Define incrementCustomPc and decrementCustomPc early so they're available for onclick handlers
window.incrementCustomPc = function() {
  var customInput = document.getElementById('customNumOfPc');
  if (customInput) {
    var current = parseInt(customInput.value) || 2;
    // Try to get max from DOM element first, then fallback to window variable, then template value
    var maxElement = document.getElementById('max-available-pcs');
    var maxAvailable = 0;
    if (maxElement) {
      maxAvailable = parseInt(maxElement.textContent) || 0;
    }
    if (!maxAvailable || maxAvailable === 0) {
      maxAvailable = window.MAX_AVAILABLE_PCS || {{ available_count|default:total_pc }};
    }
    
    // Only block if maxAvailable is 0 (no PCs available at all)
    if (maxAvailable < 1) {
      var errorMsg = document.getElementById('pc-limit-error');
      if (errorMsg) {
        errorMsg.style.display = 'block';
        errorMsg.innerHTML = '<small><i class="fa-solid fa-triangle-exclamation"></i> No PCs available. Maximum available: ' + maxAvailable + ' PC(s)</small>';
      }
      alert('No PCs available. Please check the PC availability.');
      return false;
    }
    
    // If maxAvailable < 2, allow incrementing anyway (don't enforce the limit strictly)
    // Only enforce limit if maxAvailable >= 2
    if (maxAvailable >= 2 && current >= maxAvailable) {
      var errorMsg = document.getElementById('pc-limit-error');
      if (errorMsg) {
        errorMsg.style.display = 'block';
        errorMsg.innerHTML = '<small><i class="fa-solid fa-triangle-exclamation"></i> Maximum available: ' + maxAvailable + ' PC(s)</small>';
      }
      alert('Cannot exceed ' + maxAvailable + ' available PC(s)');
      return false;
    }
    
    // Allow incrementing if maxAvailable < 2 (even if current >= maxAvailable)
    // or if maxAvailable >= 2 and current < maxAvailable
    customInput.value = current + 1;
    if (typeof window.handleCustomPcInput === 'function') {
      window.handleCustomPcInput();
    }
  }
};

window.decrementCustomPc = function() {
  var customInput = document.getElementById('customNumOfPc');
  if (customInput) {
    var current = parseInt(customInput.value) || 2;
    // Minimum is 2, so only allow decrementing if current > 2
    if (current > 2) {
      customInput.value = current - 1;
      if (typeof window.handleCustomPcInput === 'function') {
        window.handleCustomPcInput();
      }
    } else if (current === 2) {
      // Already at minimum, show alert
      alert('Minimum booking is 2 PCs. You cannot reduce below 2 PCs.');
    }
  }
};
</script>
{% endblock %}

{% block content %}
<!-- Store user role for JavaScript -->
<div data-user-role="{{ request.user.profile.role|default:'' }}" style="display: none;"></div>
<script>
  // Set global user role variable
  window.userRole = '{{ request.user.profile.role|default:'' }}';
</script>
<div class="mobile-reservation-container">
  <div class="reservation-card">
    <!-- Available PC's Card Section -->
    <div class="available-pcs-card">
      <div class="available-pcs-header">
        <h2 class="available-pcs-title">Available PC's</h2>
        <div class="available-count-badge">
          <span class="available-count-number" id="available-count">{{ available_count|default:"0" }}</span>
          <span class="available-count-label">Available</span>
        </div>
      </div>
      <div class="reservation-datetime" id="current-datetime">
        <i class="fa-solid fa-clock"></i>
        <script>
          (function() {
            var now = new Date();
            var months = ['January', 'February', 'March', 'April', 'May', 'June', 
                         'July', 'August', 'September', 'October', 'November', 'December'];
            var month = months[now.getMonth()];
            var day = now.getDate();
            var year = now.getFullYear();
            var hours = now.getHours();
            var minutes = now.getMinutes();
            var ampm = hours >= 12 ? 'PM' : 'AM';
            hours = hours % 12;
            hours = hours ? hours : 12;
            minutes = minutes < 10 ? '0' + minutes : minutes;
            var dateTime = month + ' ' + day + ', ' + year + ' | ' + hours + ':' + minutes + ' ' + ampm;
            document.getElementById('current-datetime').innerHTML = '<i class="fa-solid fa-clock"></i> ' + dateTime;
          })();
        </script>
      </div>
      
      <!-- Status Legend Section -->
      <div class="status-legend-inline">
        <div class="legend-item available">
          <div class="legend-icon">
            <i class="fa-solid fa-desktop"></i>
          </div>
          <span class="legend-text">Available</span>
        </div>
        <div class="legend-item selected">
          <div class="legend-icon">
            <i class="fa-solid fa-desktop"></i>
          </div>
          <span class="legend-text">Selected</span>
        </div>
        <div class="legend-item queue">
          <div class="legend-icon">
            <i class="fa-solid fa-desktop"></i>
          </div>
          <span class="legend-text">In Queue</span>
        </div>
        <div class="legend-item used">
          <div class="legend-icon">
            <i class="fa-solid fa-desktop"></i>
          </div>
          <span class="legend-text">Used</span>
        </div>
        <div class="legend-item repair">
          <div class="legend-icon">
            <i class="fa-solid fa-desktop"></i>
          </div>
          <span class="legend-text">Repair</span>
        </div>
      </div>
    </div>
    
    <div class="reservation-body">
      <input type="hidden" id="pc_id" name="pc_id">

      <div id="students-booking"> <!-- students-booking -->
        {% if not available_pcs %}
        <div class="alert alert-warning text-center">
          <p>No PCs found. Please add some PCs first in the PC List page.</p>
          <a href="{% url 'main_app:pc-list' %}" class="btn btn-primary">Go to PC List</a>
        </div>
        {% else %}
        <div class="pc-grid">
          {% for pc in available_pcs %}
            <div class="pc-item">
              <button class="pc-button-modern 
                {% if pc.system_condition == 'repair' %}pc-repair
                {% elif pc.status == 'disconnected' %}pc-offline
                {% elif pc.booking_status == 'in_use' %}pc-used
                {% elif pc.booking_status == 'in_queue' %}pc-queue
                {% else %}pc-available{% endif %}" 
                data-pc-id="{{ pc.id }}" 
                data-pc-name="{{ pc.name }}"
                data-pc-status="{{ pc.status }}"
                data-pc-condition="{{ pc.system_condition }}"
                data-booking-status="{{ pc.booking_status }}"
                {% if pc.system_condition == 'repair' or pc.status == 'disconnected' %}
                  onclick="event.preventDefault(); event.stopPropagation(); showPCStatus({{ pc.id }}, this);"
                  disabled
                  style="cursor: not-allowed !important; opacity: 0.6 !important; pointer-events: none;"
                  title="{% if pc.system_condition == 'repair' %}PC is in repair and not available{% elif pc.status == 'disconnected' %}PC is offline and not available{% endif %}"
                  tabindex="-1"
                {% elif pc.booking_status == 'in_use' or pc.booking_status == 'in_queue' %}
                  onclick="showPCStatus({{ pc.id }}, this); return false;"
                  style="cursor: pointer;"
                {% else %}
                  onclick="selectPCForReservation({{ pc.id }}, this); return false;"
                {% endif %}>
                <i class="fa-solid fa-desktop pc-icon-modern"></i>
                <span class="pc-number">{{ pc.name|get_int }}</span>
              </button>
            </div>
          {% endfor %}
        </div>
  
        {% if is_paginated %}
        <div class="pagination-modern">
          {% if page_obj.has_previous %}
            <a href="?page={{ page_obj.previous_page_number }}" class="pagination-arrow" id="pageNavPrev">
              <i class="fa-solid fa-arrow-left"></i>
            </a>
          {% else %}
            <span class="pagination-arrow disabled">
              <i class="fa-solid fa-arrow-left"></i>
            </span>
          {% endif %}
          
          <span class="pagination-info">{{ page_obj.number }}/{{ page_obj.paginator.num_pages }}</span>
          
          {% if page_obj.has_next %}
            <a href="?page={{ page_obj.next_page_number }}" class="pagination-arrow" id="pageNavNext">
              <i class="fa-solid fa-arrow-right"></i>
            </a>
          {% else %}
            <span class="pagination-arrow disabled">
              <i class="fa-solid fa-arrow-right"></i>
            </span>
          {% endif %}
        </div>
        {% endif %}
        {% endif %}
        
        <!-- Next Button -->
        <button type="button" class="next-button-modern reserve-next-button" disabled aria-disabled="true">
          Next <i class="fa-solid fa-chevron-right"></i>
        </button>
        
        <!-- View QR Code Button (shown when QR code is available) -->
        <div id="viewQRCodeButtonNext" style="display: none; text-align: center; margin-top: 15px; position: relative; z-index: 1000;">
          <button type="button" class="btn btn-primary btn-lg" id="viewQRCodeBtnNext" style="position: relative; z-index: 1000; width: 100%; max-width: 300px;">
            <i class="fa-solid fa-qrcode"></i> View QR Code
          </button>
        </div>

        <div id="selected-pc-indicator" class="selected-pc-indicator" hidden>
          <i class="fa-solid fa-circle-check"></i>
          <span>Selected PC:</span>
          <strong id="selected-pc-name"></strong>
        </div>
      </div> <!-- end of students-booking -->

      <!-- My Session Button (shown when user has active booking) -->
      <div id="viewQRButtonContainer" style="display: none; visibility: hidden; text-align: center; margin: 20px 0;">
        <button type="button" class="btn btn-info btn-lg" id="showMySessionBtnMain" style="display: block;">
          <i class="fa-solid fa-clock"></i> My Session
        </button>
        <button type="button" class="btn btn-primary btn-lg mt-2" id="viewQRCodeBtn" style="display: block;">
          <i class="fa-solid fa-qrcode"></i> View QR Code
        </button>
      </div>
      
      <!-- Floating Timer Widget (always visible when user has active booking) -->
      <div id="floatingTimerWidget" style="display: none; position: fixed; top: 20px; right: 20px; z-index: 1050;">
        <!-- Minimized state (shows only timer) -->
        <div class="floating-timer-minimized" id="floating-timer-minimized">
          <div class="timer-mini-content" onclick="window.toggleFloatingTimer()">
            <div id="floating-time-display-mini" class="timer-countdown-mini">--:--:--</div>
          </div>
          <div class="timer-mini-controls">
            <button type="button" class="btn-timer-control" onclick="window.toggleFloatingTimer(); return false;" title="Expand">
              <i class="fa-solid fa-chevron-down"></i>
            </button>
          </div>
        </div>
        
        <!-- Expanded state (shows full widget) -->
        <div class="floating-timer-container" id="floating-timer-expanded" style="display: none;">
          <div class="floating-timer-header">
            <i class="fa-solid fa-clock me-2"></i>
            <span>Session Timer</span>
            <div class="timer-header-controls">
              <button type="button" class="btn-close-timer" onclick="window.toggleFloatingTimer(); return false;" title="Minimize">
                <i class="fa-solid fa-chevron-up"></i>
              </button>
            </div>
          </div>
          <div class="floating-timer-display">
            <div id="floating-time-display" class="timer-countdown">--:--:--</div>
            <div id="floating-timer-status" class="timer-status">Active</div>
          </div>
          <div class="floating-timer-actions">
            <button type="button" class="btn btn-danger btn-sm w-100" id="floating-end-session-btn" data-booking-id="" onclick="window.endMySession(this); return false;">
              <i class="fa-solid fa-stop-circle me-2"></i> End Session
            </button>
          </div>
        </div>
      </div>
      
      <style>
        /* Minimized timer (compact view) */
        .floating-timer-minimized {
          background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
          border-radius: 12px;
          padding: 0.5rem;
          box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
          border: 2px solid #e9ecef;
          transition: all 0.3s ease;
          min-width: 140px;
          animation: slideInRight 0.3s ease-out;
        }
        
        .timer-mini-content {
          text-align: center;
          cursor: pointer;
          padding: 0.25rem 0;
        }
        
        .timer-mini-content:hover {
          opacity: 0.8;
        }
        
        .timer-mini-controls {
          display: flex;
          justify-content: center;
          gap: 0.5rem;
          margin-top: 0.25rem;
          padding-top: 0.25rem;
          border-top: 1px solid #e9ecef;
        }
        
        .btn-timer-control {
          background: none;
          border: none;
          color: #6c757d;
          cursor: pointer;
          padding: 0.25rem 0.5rem;
          border-radius: 4px;
          transition: all 0.2s ease;
          font-size: 0.75rem;
          display: flex;
          align-items: center;
          justify-content: center;
        }
        
        .btn-timer-control:hover {
          background: #f0f0f0;
          color: #495057;
        }
        
        .floating-timer-minimized:hover {
          box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2);
          transform: translateY(-2px);
        }
        
        .timer-countdown-mini {
          font-size: 1.1rem;
          font-weight: 700;
          color: #198754;
          font-family: 'Courier New', monospace;
          letter-spacing: 1px;
          margin: 0;
        }
        
        .timer-countdown-mini.warning {
          color: #ffc107;
        }
        
        .timer-countdown-mini.danger {
          color: #dc3545;
          animation: pulse 1s infinite;
        }
        
        /* Expanded timer (full widget) */
        .floating-timer-container {
          background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
          border-radius: 16px;
          padding: 1rem;
          box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
          border: 2px solid #e9ecef;
          min-width: 200px;
          animation: slideInRight 0.3s ease-out;
        }
        
        @keyframes slideInRight {
          from {
            transform: translateX(100%);
            opacity: 0;
          }
          to {
            transform: translateX(0);
            opacity: 1;
          }
        }
        
        .floating-timer-header {
          display: flex;
          align-items: center;
          justify-content: space-between;
          font-weight: 600;
          color: #495057;
          font-size: 0.9rem;
          margin-bottom: 0.75rem;
          padding-bottom: 0.5rem;
          border-bottom: 1px solid #e9ecef;
        }
        
        .timer-header-controls {
          display: flex;
          gap: 0.25rem;
        }
        
        .btn-close-timer {
          background: none;
          border: none;
          color: #6c757d;
          cursor: pointer;
          padding: 0.25rem 0.5rem;
          border-radius: 4px;
          transition: all 0.2s ease;
          font-size: 0.8rem;
          display: flex;
          align-items: center;
          justify-content: center;
        }
        
        .btn-close-timer:hover {
          background: #f0f0f0;
          color: #495057;
        }
        
        .floating-timer-display {
          text-align: center;
          margin-bottom: 0.75rem;
        }
        
        .timer-countdown {
          font-size: 1.5rem;
          font-weight: 700;
          color: #198754;
          font-family: 'Courier New', monospace;
          letter-spacing: 1px;
          margin-bottom: 0.25rem;
        }
        
        .timer-countdown.warning {
          color: #ffc107;
        }
        
        .timer-countdown.danger {
          color: #dc3545;
          animation: pulse 1s infinite;
        }
        
        .timer-status {
          font-size: 0.75rem;
          color: #6c757d;
          text-transform: uppercase;
          letter-spacing: 0.5px;
        }
        
        .floating-timer-actions {
          margin-top: 0.5rem;
        }
        
        .floating-timer-actions .btn {
          border-radius: 8px;
          font-weight: 600;
          padding: 0.5rem 1rem;
          transition: all 0.2s ease;
        }
        
        .floating-timer-actions .btn:hover {
          transform: translateY(-2px);
          box-shadow: 0 4px 12px rgba(220, 53, 69, 0.3);
        }
        
        @keyframes pulse {
          0%, 100% {
            opacity: 1;
          }
          50% {
            opacity: 0.7;
          }
        }
        
        /* Responsive adjustments */
        @media (max-width: 768px) {
          #floatingTimerWidget {
            top: 10px;
            right: 10px;
          }
          
          .floating-timer-container {
            min-width: 180px;
            padding: 0.75rem;
          }
          
          .timer-countdown {
            font-size: 1.25rem;
          }
        }
      </style>
      
      <script>
        // Toggle floating timer between minimized and expanded states
        if (typeof window.toggleFloatingTimer === 'undefined') {
          window.toggleFloatingTimer = function() {
            var minimized = document.getElementById('floating-timer-minimized');
            var expanded = document.getElementById('floating-timer-expanded');
            
            if (minimized && expanded) {
              if (minimized.style.display === 'none') {
                // Currently expanded, minimize it
                minimized.style.display = 'block';
                expanded.style.display = 'none';
              } else {
                // Currently minimized, expand it
                minimized.style.display = 'none';
                expanded.style.display = 'block';
              }
            }
          };
        }
        
      </script>

      {% if request.user.is_authenticated and request.user.profile.role|default:'' == 'faculty' %}
      <div class="text-center my-3">
        <button type="button" class="btn btn-success" id="block-button">
          Bulk booking for class
        </button>
      </div>
      {% endif %}

      <!-- PC Selection Modal -->
      <div class="modal fade" id="pcSelectionModal" tabindex="-1" aria-labelledby="pcSelectionModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
          <div class="modal-content">
            <div class="modal-header">
              <h5 class="modal-title" id="pcSelectionModalLabel">
                <i class="fa-solid fa-desktop me-2"></i>Select Number of PCs
              </h5>
            </div>
            <div class="modal-body">
              <div id="faculty-booking-pc-group">
                <div class="text-center mb-3">
                  <small class="text-muted">Maximum available: <strong id="max-available-pcs">{{ available_count|default:total_pc }}</strong> PC(s)</small>
                </div>
                <div class="row justify-content-center text-center">
                  <div class="mb-3 pc-container text-black">
                  {% with max_available=available_count|default:total_pc %}
                  {% for i in total_pc|divide:5|integer|to_range %}
                    {% if i|multiply:5 != total_pc and i|multiply:5 <= max_available %}
                    <button class="pc-group-number" id="pcs-{{ i|multiply:5 }}" data-qty="{{ i|multiply:5 }}" onclick="handlePcGroupClick(this)">
                      <span>{{ i|multiply:5 }}</span>
                    </button>
                    {% elif i|multiply:5 > max_available %}
                    <button class="pc-group-number" id="pcs-{{ i|multiply:5 }}" data-qty="{{ i|multiply:5 }}" disabled style="opacity: 0.5; cursor: not-allowed;" title="Exceeds available PCs">
                      <span>{{ i|multiply:5 }}</span>
                    </button>
                    {% endif %}
                  {% endfor %}
                    {% if total_pc <= max_available %}
                    <button class="pc-group-number" id="pcs-{{ total_pc }}" data-qty="{{ total_pc}}" onclick="handlePcGroupClick(this)">
                      <span>{{ total_pc }}</span>
                    </button>
                    {% else %}
                    <button class="pc-group-number" id="pcs-{{ total_pc }}" data-qty="{{ total_pc}}" disabled style="opacity: 0.5; cursor: not-allowed;" title="Exceeds available PCs">
                      <span>{{ total_pc }}</span>
                    </button>
                    {% endif %}
                  {% endwith %}
                  </div>
                  <div class="text-center mb-3" style="max-width:250px; margin:auto;">
                    <label for="customNumOfPc" class="form-label mb-2">Number Of PC</label>
                    <div class="input-group justify-content-center">
                      <button class="btn btn-outline-secondary" type="button" id="fb-minusBtn" onclick="decrementCustomPc()">âˆ’</button>
                      <input type="number" id="customNumOfPc" name="customNumOfPc" class="form-control text-center" value="2" min="2" max="{{ available_count|default:total_pc }}" oninput="if (typeof handleCustomPcInput === 'function') handleCustomPcInput()" required>
                      <button class="btn btn-outline-secondary" type="button" id="fb-plusBtn" onclick="incrementCustomPc()">+</button>
                    </div>
                  </div>
                  <div id="pc-limit-error" class="text-center text-danger mb-2" style="display: none;">
                    <small><i class="fa-solid fa-triangle-exclamation"></i> Cannot exceed available PCs</small>
                  </div>
                </div>
              </div>
            </div>
            <div class="modal-footer d-flex justify-content-between align-items-center">
              <button type="button" id="pc-selection-cancel-btn" class="btn btn-secondary" onclick="closeModalAndScrollToReservationCard()">
                <i class="fa-solid fa-chevron-left me-2"></i> Back
              </button>
              <button type="button" class="btn btn-success" id="block-button-next" onclick="if (typeof goToBlockBookingForm === 'function') goToBlockBookingForm()">
                Next <i class="fa-solid fa-chevron-right ms-2"></i>
              </button>
            </div>
          </div>
        </div>
      </div>

      <!-- Faculty Form -->
      <div class="form-section card-body p-4 bulk-booking-card shadow-lg" id="faculty-form-section" hidden>
        <form method="post" id="facultyForm" enctype="multipart/form-data" action="{% url 'main_app:submit-block-booking' %}">
          {% csrf_token %}
          <input type="number" id="custNumOfPc" name="custNumOfPc" hidden>
          <input type="number" id="numOfPc" name="numOfPc" hidden>
          
          <!-- Step 1: Class Details -->
          <div class="step active" id="step1">
            <div class="bulk-step-header text-center mb-4">
              <h3 class="bulk-step-title mb-2">Class Details</h3>
              <p class="bulk-step-subtitle mb-0">Provide the key information for your bulk booking session.</p>
            </div>
            
            <div class="row g-3 mb-4">
              <div class="col-12 col-md-6">
                <label for="course" class="form-label fw-semibold">Course <span class="text-danger">*</span></label>
                <input type="text" id="course" name="course" class="form-control bulk-input" placeholder="e.g., BSIT" required>
                <div class="invalid-feedback">Please enter a course.</div>
              </div>
              <div class="col-12 col-md-6">
                <label for="block" class="form-label fw-semibold">Block <span class="text-danger">*</span></label>
                <input type="text" id="block" name="block" class="form-control bulk-input" placeholder="e.g., 3A" required>
                <div class="invalid-feedback">Please enter a block.</div>
              </div>
              <div class="col-12">
                <label for="college" class="form-label fw-semibold">College <span class="text-danger">*</span></label>
                <select id="college" name="college" class="form-control select bulk-input" required>
                  <option value="" selected disabled hidden>Select College</option>
                  {% for college in colleges %}
                  <option value="{{ college.id }}">{{ college.name }}</option>
                  {% endfor %}
                </select>
                <div class="invalid-feedback">Please select a college.</div>
              </div>
              <div class="col-12 col-md-6">
                <label for="dateStart" class="form-label fw-semibold">Start Date & Time <span class="text-danger">*</span></label>
                <input type="datetime-local" id="dateStart" name="dateStart" class="form-control bulk-input" required>
                <div class="invalid-feedback">Please select a start date and time.</div>
              </div>
              <div class="col-12 col-md-6">
                <label for="dateEnd" class="form-label fw-semibold">End Date & Time <span class="text-danger">*</span></label>
                <input type="datetime-local" id="dateEnd" name="dateEnd" class="form-control bulk-input" required>
                <div class="invalid-feedback">Please select an end date and time.</div>
              </div>
            </div>
            
            <!-- Navigation Buttons -->
            <div class="bulk-step-actions mt-4">
              <button type="button" class="btn btn-outline-secondary bulk-back" id="step1BackBtn" data-bs-toggle="modal" data-bs-target="#pcSelectionModal" onclick="backToPcSelection(); return false;">
                Back
              </button>
              <button type="button" class="btn btn-primary bulk-next" id="step1NextBtn" onclick="if (typeof window.validateStep1 === 'function') { window.validateStep1(); } else { console.error('validateStep1 function not found'); } return false;">
                Next
              </button>
            </div>
          </div>

          <!-- Step 2: Email addresses -->
          <div class="step" id="step2">
            <div class="bulk-step-header text-center mb-4">
              <h3 class="bulk-step-title mb-2">Invite Students</h3>
              <p class="bulk-step-subtitle mb-0">Enter PSU email addresses separated by commas. We will notify each student.</p>
            </div>
            
            <div class="mb-4">
              <label for="emailList" class="form-label fw-semibold">Student Email Addresses <span class="text-danger">*</span></label>
              <textarea name="emailList" id="emailList" rows="8" class="form-control bulk-textarea" placeholder="student1@psu.palawan.edu.ph, student2@psu.palawan.edu.ph" oninput="validateEmailList(this)" required></textarea>
              <div id="result" class="bulk-validation-feedback mt-2"></div>
              <small class="form-text text-muted">Separate multiple emails with commas.</small>
            </div>
            
            <div class="mb-4">
              <label for="attachment" class="form-label fw-semibold">Approval Letter <span class="text-muted">(Optional)</span></label>
              <input type="file" name="attachment" id="attachment" class="form-control bulk-input" accept=".pdf,.doc,.docx,.jpg,.png">
              <small class="form-text text-muted">Accepted formats: PDF, DOC, DOCX, JPG, PNG</small>
            </div>
            
            <!-- Navigation Buttons -->
            <div class="bulk-step-actions mt-4">
              <button type="button" class="btn btn-outline-secondary bulk-back" onclick="goBackStep('step2', 'step1')">
                <i class="fa-solid fa-arrow-left me-2"></i> Back
              </button>
              <button type="submit" class="btn btn-success bulk-submit" id="step2SubmitBtn" hidden onclick="return submitFacultyForm(event);">
                <i class="fa-solid fa-paper-plane me-2"></i> Submit Request
              </button>
            </div>
          </div>

          <!-- Step 3: Attachment -->
          <div class="step" id="step3">
            <div class="bulk-step-header text-center mb-4">
              <h3 class="bulk-step-title mb-2">Upload Approval Letter</h3>
              <p class="bulk-step-subtitle mb-0">Attach the request letter signed by your Dean to complete the submission.</p>
            </div>
            
            <div class="mb-4">
              <label for="attachment" class="form-label fw-semibold">Approval Letter <span class="text-muted">(Optional)</span></label>
              <input type="file" name="attachment" id="attachment" class="form-control bulk-input" accept=".pdf,.doc,.docx,.jpg,.png">
              <small class="form-text text-muted">Accepted formats: PDF, DOC, DOCX, JPG, PNG</small>
            </div>
            
            <!-- Navigation Buttons -->
            <div class="bulk-step-actions mt-4">
              <button type="button" class="btn btn-outline-secondary bulk-back" onclick="goBackStep('step3', 'step2')">
                <i class="fa-solid fa-arrow-left me-2"></i> Back
              </button>
              <button type="submit" class="btn btn-success bulk-submit" id="facultyFormSubmit">
                <i class="fa-solid fa-paper-plane me-2"></i> Submit Request
              </button>
            </div>
          </div>
        </form>
      </div>

      <!-- Duration Modal -->
      <div class="modal fade" id="durationModal" tabindex="-1" aria-labelledby="durationModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
          <div class="modal-content rounded-3 shadow">
            <div class="modal-header">
              <h5 class="modal-title" id="durationModalLabel">SET TIME</h5>
              <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body text-center">
              <div class="input-group justify-content-center" style="max-width:300px; margin:auto;">
                <button class="btn btn-outline-secondary" type="button" id="minusBtn">âˆ’</button>
                <input type="text" id="durationInput" class="form-control text-center" value="00:05:00" pattern="^([0-1][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9]$" placeholder="00:00:00" maxlength="8">
                <button class="btn btn-outline-secondary" type="button" id="plusBtn">+</button>
              </div>
              <small class="text-muted">Time format: HH:MM:SS (Maximum 03:00:00)</small>
            </div>
            <div class="modal-footer">
              <input type="number" name="" id="pc_id" hidden>
              <button type="button" id="generate-qr-button" class="btn btn-success" data-reserve-url="{% url 'main_app:reserve-pc' %}">Generate QR Code</button>
            </div>
          </div>
        </div>
      </div>

      <!-- QR Code Modal -->
      <div class="modal fade" id="qrModal" tabindex="-1" aria-hidden="true">
        <div class="modal-dialog modal-sm modal-dialog-centered">
          <div class="modal-content rounded-3 shadow text-center">
            <div class="modal-header">
              <h5 class="modal-title">Your Reservation QR</h5>
              <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
              <img id="qrImage" src="" alt="QR Code" class="img-fluid mb-3">
              <span id="booking_id" hidden></span>
              <input type="number" id="qr_booking_pc_id" hidden>
              <div>
                <small class="text-muted">Expires in <span id="qrCountdown">10:00</span></small>
              </div>
              <p style="font-size: x-small;">Note: <br>
                Use this QR code before it expires to confirm your booking.
                Confirming site is at the Ict desk info.
              </p>
            </div>
            <div class="modal-footer justify-content-center">
              <button type="button" class="btn btn-danger btn-sm" id="endQRSessionBtn">
                <i class="fa-solid fa-stop"></i> End Session
              </button>
            </div>
          </div>
        </div>
      </div>

      <!-- Custom Confirmation Modal -->
      <div class="modal fade" id="confirmEndSessionModal" tabindex="-1" aria-labelledby="confirmEndSessionLabel" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
          <div class="modal-content border-0 shadow-lg">
            <div class="modal-header bg-danger text-white border-0">
              <h5 class="modal-title" id="confirmEndSessionLabel">
                <i class="fa-solid fa-exclamation-triangle me-2"></i>Confirm End Session
              </h5>
              <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body text-center py-4">
              <div class="mb-3">
                <i class="fa-solid fa-circle-question text-danger" style="font-size: 3rem;"></i>
              </div>
              <h6 class="mb-3">Are you sure you want to end your booking session?</h6>
              <p class="text-muted mb-0">This will cancel your reservation and you will need to create a new booking.</p>
            </div>
            <div class="modal-footer border-0 justify-content-center pb-4">
              <button type="button" class="btn btn-secondary me-2" data-bs-dismiss="modal">
                <i class="fa-solid fa-times me-1"></i>Cancel
              </button>
              <button type="button" class="btn btn-danger" id="confirmEndSessionBtn">
                <i class="fa-solid fa-stop me-1"></i>End Session
              </button>
            </div>
          </div>
        </div>
      </div>

      <!-- Remaining Time Modal -->
      <div class="modal fade" id="timeRemainingModal" tabindex="-1" aria-labelledby="timeRemainingLabel" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
          <div class="modal-content text-center">
            <div class="modal-header bg-warning">
              <h5 class="modal-title" id="timeRemainingLabel">Booking Active</h5>
            </div>
            <div class="modal-body text-center bg-dark text-white ps-2 pt-10 pe-2 pb-10">
              <i class="fa-solid fa-desktop mb-2" style="font-size: xx-large;"></i>
              <p>Time remaining 
                <br> 
                <span class="fw-bold" id="timeRemaining"></span>
              </p>
              <div class="mt-4">
                <button type="button" class="btn btn-danger btn-lg" id="end-session-early-btn" data-booking-id="" onclick="if(typeof window.handleEndSessionEarly === 'function') return window.handleEndSessionEarly(); return false;">
                  <i class="fa-solid fa-stop-circle"></i> End Session Early
                </button>
              </div>
              <div class="mt-3">
                <p class="text-warning mb-0" style="font-size: 0.9rem;">
                  <i class="fa-solid fa-info-circle"></i> 
                  <strong>Note:</strong> To extend your session time, please go to the front desk or contact an admin.
                </p>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- PC Status Modal -->
      <div class="modal fade" id="pcStatusModal" tabindex="-1" aria-labelledby="pcStatusModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
          <div class="modal-content">
            <div class="modal-header" id="pcStatusModalHeader">
              <h5 class="modal-title" id="pcStatusModalLabel">
                <i class="fa-solid fa-desktop"></i> PC Status
              </h5>
              <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body text-center" id="pcStatusModalBody">
              <div id="pcStatusContent">
                <!-- Content will be populated by JavaScript -->
              </div>
            </div>
            <div class="modal-footer">
              <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
              <button type="button" class="btn btn-danger" id="pc-status-end-session-btn" style="display: none;" data-booking-id="">
                <i class="fa-solid fa-stop-circle"></i> End Session Early
              </button>
            </div>
          </div>
        </div>
      </div>

      <!-- Custom Alert Modal -->
      <div class="modal fade" id="customAlertModal" tabindex="-1" aria-labelledby="customAlertModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
          <div class="modal-content custom-alert-content">
            <div class="modal-header custom-alert-header">
              <h5 class="modal-title custom-alert-title" id="customAlertModalLabel">
                <i class="fa-solid fa-clock"></i> Time Restriction
              </h5>
            </div>
            <div class="modal-body custom-alert-body">
              <div class="custom-alert-icon">
                <i class="fa-solid fa-exclamation-triangle"></i>
              </div>
              <p class="custom-alert-message" id="customAlertMessage"></p>
              <p class="custom-alert-time" id="customAlertTime"></p>
            </div>
            <div class="modal-footer custom-alert-footer">
              <button type="button" class="btn custom-alert-btn" data-bs-dismiss="modal" id="customAlertOkBtn">OK</button>
            </div>
          </div>
        </div>
      </div>

    </div> <!-- end of reservation-body -->
  </div> <!-- end of reservation-card -->

</div>

<!-- Student Active Session Modal -->
<div class="modal fade" id="mySessionModal" tabindex="-1" aria-labelledby="mySessionModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered">
    <div class="modal-content">
      <div class="modal-header bg-success text-white">
        <h5 class="modal-title" id="mySessionModalLabel">
          <i class="fa-solid fa-desktop"></i> Your Active Session
        </h5>
        <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body text-center">
        <h3 id="session-pc-name">PC XXX</h3>
        <p class="mb-3">
          <strong>Status:</strong> <span id="session-status" class="badge bg-warning">In Queue</span>
        </p>
        <div id="session-time-info" style="display: none;">
          <p><strong>Time Remaining:</strong></p>
          <!-- End Session Button at top of timer -->
          <div class="mb-3" id="end-session-top-container">
            <button type="button" class="btn btn-danger btn-lg" id="end-session-top-btn" style="display: none;" data-booking-id="" onclick="window.endMySession(this); return false;">
              <i class="fa-solid fa-stop-circle me-2"></i> End Session
            </button>
          </div>
          <h2 class="text-primary" id="session-time-left">0h 0m</h2>
          <p class="text-muted small mt-2" id="session-end-time"></p>
        </div>
        <div id="session-waiting" class="alert alert-warning">
          <i class="fa-solid fa-hourglass-half"></i><br>
          Waiting for staff approval...
          <!-- End Session Button for pending bookings -->
          <div class="mt-3" id="end-session-pending-container">
            <button type="button" class="btn btn-danger btn-lg" id="end-session-pending-btn" style="display: none;" data-booking-id="" onclick="window.endMySession(this); return false;">
              <i class="fa-solid fa-stop-circle me-2"></i> Cancel Booking
            </button>
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
        <button type="button" class="btn btn-danger" id="end-session-btn" style="display: none;" data-booking-id="" onclick="window.endMySession(this); return false;">
          <i class="fa-solid fa-stop-circle"></i> End Session Early
        </button>
      </div>
      <div class="modal-body border-top">
        <p class="text-warning mb-0 text-center" style="font-size: 0.9rem;">
          <i class="fa-solid fa-info-circle"></i> 
          <strong>Note:</strong> To extend your session time, please go to the front desk or contact an admin.
        </p>
      </div>
    </div>
  </div>
</div>

{% endblock %}

{% block scripts %}
<script>
// Define PC selection functions immediately to ensure they're available for onclick handlers
(function() {
  // Function to handle custom PC number input
  window.handleCustomPcInput = function() {
    var customInput = document.getElementById('customNumOfPc');
    var custNumOfPcHidden = document.getElementById('custNumOfPc');
    var blockButtonNext = document.getElementById('block-button-next');
    var errorMsg = document.getElementById('pc-limit-error');
    
    if (!customInput) return;
    
    var value = parseInt(customInput.value) || 2;
    var maxAvailable = window.MAX_AVAILABLE_PCS || 0;
    
    // Enforce minimum of 2 PCs
    if (value < 2) {
      value = 2;
      customInput.value = 2;
      alert('Minimum booking is 2 PCs. Value has been set to 2.');
    }
    
    // Validate against max available
    if (value > maxAvailable) {
      value = maxAvailable;
      customInput.value = maxAvailable;
      if (errorMsg) {
        errorMsg.style.display = 'block';
        errorMsg.innerHTML = '<small><i class="fa-solid fa-triangle-exclamation"></i> Maximum available: ' + maxAvailable + ' PC(s)</small>';
      }
      customInput.classList.add('is-invalid');
    } else if (value < 2) {
      value = 2;
      customInput.value = 2;
      customInput.classList.remove('is-invalid');
    } else {
      if (errorMsg) {
        errorMsg.style.display = 'none';
      }
      customInput.classList.remove('is-invalid');
    }
    
    if (custNumOfPcHidden) {
      custNumOfPcHidden.value = value;
    }
    
    // Clear any selected PC group buttons when using custom input
    if (value > 0) {
      var allPcGroupButtons = document.querySelectorAll('.pc-group-number');
      allPcGroupButtons.forEach(function(btn) {
        btn.classList.remove('bg-warning');
        btn.disabled = false;
      });
    }
    
    // Show next button if value >= 2 and valid
    if (blockButtonNext) {
      var shouldShow = (value >= 2 && value <= maxAvailable && customInput.value.trim() !== '');
      blockButtonNext.hidden = !shouldShow;
      if (shouldShow) {
        blockButtonNext.style.display = 'inline-block';
        blockButtonNext.removeAttribute('hidden');
      } else {
        blockButtonNext.hidden = true;
        blockButtonNext.setAttribute('hidden', 'true');
      }
    }
    
    // Update button states
    if (typeof updateCustomPcButtons === 'function') {
      updateCustomPcButtons();
    }
  };

  // Plus button for custom PC count
  window.incrementCustomPc = function() {
    var customInput = document.getElementById('customNumOfPc');
    if (customInput) {
      var current = parseInt(customInput.value) || 2;
      var maxAvailable = window.MAX_AVAILABLE_PCS || 0;
      
      if (current >= maxAvailable) {
        var errorMsg = document.getElementById('pc-limit-error');
        if (errorMsg) {
          errorMsg.style.display = 'block';
          errorMsg.innerHTML = '<small><i class="fa-solid fa-triangle-exclamation"></i> Maximum available: ' + maxAvailable + ' PC(s)</small>';
        }
        alert('Cannot exceed ' + maxAvailable + ' available PC(s)');
        return false;
      }
      
      customInput.value = current + 1;
      window.handleCustomPcInput();
    }
  };

  // Minus button for custom PC count
  window.decrementCustomPc = function() {
    var customInput = document.getElementById('customNumOfPc');
    if (customInput) {
      var current = parseInt(customInput.value) || 2;
      if (current > 1) {
        customInput.value = current - 1;
        window.handleCustomPcInput();
      }
    }
  };

  // Max button - sets value to all available PCs
  window.setMaxPcs = function() {
    var customInput = document.getElementById('customNumOfPc');
    if (customInput) {
      var maxAvailable = window.MAX_AVAILABLE_PCS || 0;
      if (maxAvailable > 0) {
        customInput.value = maxAvailable;
        window.handleCustomPcInput();
      }
    }
  };
})();

// Count available PCs and update the count badge
function updateAvailableCount() {
  var availableCount = 0;
  var pcButtons = document.querySelectorAll('.pc-button-modern');
  
  pcButtons.forEach(function(button) {
    var pcBookingStatus = button.getAttribute('data-booking-status');
    var pcCondition = button.getAttribute('data-pc-condition');
    var pcStatus = button.getAttribute('data-pc-status');
    
    // Count as available if: not in use, not in queue, not in repair, not offline
    if (pcBookingStatus !== 'in_use' && 
        pcBookingStatus !== 'in_queue' && 
        pcCondition !== 'repair' && 
        pcStatus !== 'disconnected') {
      availableCount++;
    }
  });
  
  var countElement = document.getElementById('available-count');
  if (countElement) {
    countElement.textContent = availableCount;
  }
}

// Initialize when DOM is ready
function initReservationPage() {
  updateAvailableCount();
  
  // Disable available PCs if faculty has active booking
  if (window.__hasActiveFacultyBooking) {
    var pcButtons = document.querySelectorAll('.pc-button-modern');
    pcButtons.forEach(function(button) {
      var pcBookingStatus = button.getAttribute('data-booking-status');
      var pcCondition = button.getAttribute('data-pc-condition');
      var pcStatus = button.getAttribute('data-pc-status');
      
      // Only disable available PCs (not repair, offline, in_use, or in_queue)
      if (pcBookingStatus !== 'in_use' && 
          pcBookingStatus !== 'in_queue' && 
          pcCondition !== 'repair' && 
          pcStatus !== 'disconnected') {
        button.disabled = true;
        button.style.cursor = 'not-allowed';
        button.style.opacity = '0.6';
        button.style.pointerEvents = 'none';
        button.onclick = function() {
          alert('You have an active faculty booking. Please wait for your current booking to be processed or cancelled before booking another PC.');
          return false;
        };
      }
    });
  }
  
  // Update available count when PC selection changes
  var pcButtons = document.querySelectorAll('.pc-button-modern');
  pcButtons.forEach(function(button) {
    button.addEventListener('click', function() {
      setTimeout(updateAvailableCount, 100);
    });
  });
}

// Initialize when DOM is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initReservationPage);
} else {
  // DOM is already loaded
  initReservationPage();
}

// showPCStatus and selectPCForReservation are now defined in the extra_head block section above
// so they're available before the HTML that uses them

// Function to show block booking form (vanilla JS fallback)
function showBlockBooking() {
  console.log('Block booking button clicked (vanilla JS)');
  var studentsBooking = document.getElementById('students-booking');
  var legend = document.getElementById('legend');
  var blockPcGroup = document.getElementById('faculty-booking-pc-group');
  var blockButton = document.getElementById('block-button');
  
  // Check if button is disabled
  if (blockButton && (blockButton.disabled || blockButton.getAttribute('disabled'))) {
    console.log('Block button is disabled');
    return false;
  }
  
  // Check if faculty has active booking (if flag is set)
  if (window.__hasActiveFacultyBooking === true) {
    alert('You have an active booking. Please wait for your current booking to be processed or cancelled before creating a new one.');
    return false;
  }
  
  if (studentsBooking) studentsBooking.style.display = 'none';
  if (legend) legend.style.display = 'none';
  if (blockPcGroup) blockPcGroup.removeAttribute('hidden');
  if (blockButton) blockButton.style.display = 'none';
  
  console.log('Block booking form shown');
  return true;
}

// Also set up vanilla JS event listener as fallback
document.addEventListener('DOMContentLoaded', function() {
  var blockButton = document.getElementById('block-button');
  if (blockButton && !blockButton.hasAttribute('data-handler-attached')) {
    blockButton.setAttribute('data-handler-attached', 'true');
    blockButton.addEventListener('click', function(e) {
      // Only use vanilla JS handler if jQuery handler didn't run
      // Check if jQuery is available and if the handler already processed this
      if (typeof jQuery === 'undefined' || typeof $ === 'undefined') {
        e.preventDefault();
        showBlockBooking();
      }
    });
  }
});

// Get max available PCs (set from template)
// Initialize when DOM is ready
var MAX_AVAILABLE_PCS = 0;
window.MAX_AVAILABLE_PCS = 0;
function initMaxAvailablePCs() {
  var maxElement = document.getElementById('max-available-pcs');
  if (maxElement) {
    MAX_AVAILABLE_PCS = parseInt(maxElement.textContent) || {{ available_count|default:total_pc }};
  } else {
    MAX_AVAILABLE_PCS = {{ available_count|default:total_pc }};
  }
  window.MAX_AVAILABLE_PCS = MAX_AVAILABLE_PCS;
  console.log('Max available PCs:', MAX_AVAILABLE_PCS);
  
  // Initialize button states
  if (document.getElementById('customNumOfPc')) {
    updateCustomPcButtons();
    // Validate and set Next button state
    if (typeof window.handleCustomPcInput === 'function') {
      window.handleCustomPcInput();
    }
  }
  
  // Add event listener for when modal is shown to validate button state
  var pcSelectionModal = document.getElementById('pcSelectionModal');
  if (pcSelectionModal) {
    pcSelectionModal.addEventListener('shown.bs.modal', function() {
      // Validate Next button state when modal opens
      var customInput = document.getElementById('customNumOfPc');
      if (customInput && typeof window.handleCustomPcInput === 'function') {
        window.handleCustomPcInput();
      }
    });
  }
}

// Initialize on DOM ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initMaxAvailablePCs);
} else {
  initMaxAvailablePCs();
}

// Function to handle PC group button click
function handlePcGroupClick(button) {
  console.log('PC group button clicked');
  var qty = parseInt(button.getAttribute('data-qty'));
  var numOfPcInput = document.getElementById('numOfPc');
  var custNumOfPcInput = document.getElementById('custNumOfPc');
  var blockButtonNext = document.getElementById('block-button-next');
  var errorMsg = document.getElementById('pc-limit-error');
  
  // Check if quantity exceeds available PCs
  if (qty > MAX_AVAILABLE_PCS) {
    if (errorMsg) {
      errorMsg.style.display = 'block';
      errorMsg.textContent = 'Cannot select ' + qty + ' PCs. Maximum available: ' + MAX_AVAILABLE_PCS + ' PC(s)';
    }
    alert('Cannot select ' + qty + ' PCs. Maximum available: ' + MAX_AVAILABLE_PCS + ' PC(s)');
    return false;
  }
  
  // Hide error message
  if (errorMsg) {
    errorMsg.style.display = 'none';
  }
  
  console.log('Selected quantity:', qty);
  
  if (numOfPcInput) numOfPcInput.value = qty;
  if (custNumOfPcInput) custNumOfPcInput.value = qty;
  
  // Clear other button selections first
  var allPcGroupButtons = document.querySelectorAll('.pc-group-number');
  var isSelected = button.classList.contains('bg-warning');
  
  // Toggle selected state
  button.classList.toggle('bg-warning');
  isSelected = button.classList.contains('bg-warning');
  
  // Disable other buttons
  allPcGroupButtons.forEach(function(btn) {
    if (btn !== button) {
      btn.disabled = isSelected;
      if (isSelected) {
        btn.classList.remove('bg-warning');
      }
    }
  });
  
  // Clear custom input if a button is selected
  var customInput = document.getElementById('customNumOfPc');
  if (customInput && isSelected) {
    customInput.value = qty;
  }
  
  // Show/hide next button
  if (blockButtonNext) {
    if (isSelected) {
      blockButtonNext.hidden = false;
      blockButtonNext.style.display = 'inline-block';
      blockButtonNext.removeAttribute('hidden');
    } else {
      blockButtonNext.hidden = true;
      blockButtonNext.setAttribute('hidden', 'true');
    }
    console.log('Next button hidden:', blockButtonNext.hidden);
  }
  
  // Update increment/decrement button states
  updateCustomPcButtons();
}

// Function to go to next step in block booking
window.goToBlockBookingForm = function goToBlockBookingForm() {
  // Validate that a PC is selected
  var customInput = document.getElementById('customNumOfPc');
  var selectedPcButton = document.querySelector('.pc-group-number.bg-warning');
  var errorMsg = document.getElementById('pc-limit-error');
  
  var pcCount = 0;
  
  // Check if a PC group button is selected
  if (selectedPcButton) {
    pcCount = parseInt(selectedPcButton.getAttribute('data-qty')) || 0;
  }
  
  // Check custom input value
  if (customInput) {
    var inputValue = customInput.value.trim();
    if (inputValue !== '') {
      var customValue = parseInt(inputValue) || 0;
      if (customValue >= 1) {
        pcCount = customValue;
      }
    }
  }
  
  // Validate that at least 1 PC is selected
  if (pcCount < 1) {
    // Show error message
    if (errorMsg) {
      errorMsg.style.display = 'block';
      errorMsg.innerHTML = '<small><i class="fa-solid fa-triangle-exclamation"></i> Please select at least 1 PC</small>';
    }
    // Highlight the input field
    if (customInput) {
      customInput.classList.add('is-invalid');
      customInput.focus();
    }
    alert('Please select at least 1 PC before proceeding.');
    return false;
  }
  
  // Hide error message if validation passes
  if (errorMsg) {
    errorMsg.style.display = 'none';
  }
  if (customInput) {
    customInput.classList.remove('is-invalid');
  }
  
  // Close the PC selection modal
  var pcSelectionModal = document.getElementById('pcSelectionModal');
  if (pcSelectionModal && typeof bootstrap !== 'undefined') {
    var modalInstance = bootstrap.Modal.getInstance(pcSelectionModal);
    if (modalInstance) {
      modalInstance.hide();
    }
  }
  
  var legendAndControl = document.getElementById('legend-and-control');
  var facultyFormSection = document.getElementById('faculty-form-section');
  
  if (legendAndControl) legendAndControl.setAttribute('hidden', 'true');
  if (facultyFormSection) {
    facultyFormSection.removeAttribute('hidden');
    // Scroll to form
    setTimeout(function() {
      facultyFormSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
    }, 300);
  }
  
  console.log('Showing faculty block booking form');
}

// Function to update custom PC increment/decrement button states
function updateCustomPcButtons() {
  var customInput = document.getElementById('customNumOfPc');
  var plusBtn = document.getElementById('fb-plusBtn');
  var minusBtn = document.getElementById('fb-minusBtn');
  var errorMsg = document.getElementById('pc-limit-error');
  
  if (!customInput) return;
  
  var value = parseInt(customInput.value) || 2;
  var maxAvailable = window.MAX_AVAILABLE_PCS || MAX_AVAILABLE_PCS || 0;
  
  // Update plus button (disable if at max)
  if (plusBtn) {
    if (value >= maxAvailable) {
      plusBtn.disabled = true;
      plusBtn.style.opacity = '0.5';
      plusBtn.style.cursor = 'not-allowed';
    } else {
      plusBtn.disabled = false;
      plusBtn.style.opacity = '1';
      plusBtn.style.cursor = 'pointer';
    }
  }
  
  // Update minus button (disable if at 2, minimum)
  if (minusBtn) {
    if (value <= 2) {
      minusBtn.disabled = true;
      minusBtn.style.opacity = '0.5';
      minusBtn.style.cursor = 'not-allowed';
    } else {
      minusBtn.disabled = false;
      minusBtn.style.opacity = '1';
      minusBtn.style.cursor = 'pointer';
    }
  }
  
  // Show/hide error message
  if (errorMsg) {
    if (value > maxAvailable) {
      errorMsg.style.display = 'block';
      errorMsg.innerHTML = '<small><i class="fa-solid fa-triangle-exclamation"></i> Cannot exceed ' + maxAvailable + ' available PC(s)</small>';
      customInput.classList.add('is-invalid');
    } else {
      errorMsg.style.display = 'none';
      customInput.classList.remove('is-invalid');
    }
  }
}

// Function to validate email list and show/hide Next button
function validateEmailList(textarea) {
  var input = textarea.value;
  var emails = input.split(',').map(e => e.trim()).filter(e => e.length > 0);
  var emailPattern = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  var step2SubmitBtn = document.getElementById('step2SubmitBtn');
  
  // Check if all emails are valid
  var allValid = emails.length > 0 && emails.every(email => emailPattern.test(email));
  
  if (step2SubmitBtn) {
    step2SubmitBtn.hidden = !allValid;
    console.log('Email validation - Valid emails:', allValid, 'Total:', emails.length);
  }
}

// Function to validate Step 1 before advancing
// Note: validateStep1 is now defined in the extra_head block to ensure it's available early
// This comment is kept for reference

// Function to submit the faculty form
window.submitFacultyForm = function(event) {
  if (event) {
    event.preventDefault();
    event.stopPropagation();
  }
  
  console.log('Submitting faculty form');
  
  // Validate Step 1 fields manually (without calling validateStep1 to avoid step navigation)
  var course = document.getElementById('course');
  var block = document.getElementById('block');
  var college = document.getElementById('college');
  var dateStart = document.getElementById('dateStart');
  var dateEnd = document.getElementById('dateEnd');
  var numOfPc = document.getElementById('numOfPc');
  var custNumOfPc = document.getElementById('custNumOfPc');
  var customNumOfPc = document.getElementById('customNumOfPc');
  
  var errors = [];
  
  // Validate Course (required)
  if (!course || !course.value.trim()) {
    errors.push('Please enter a course');
  }
  
  // Validate Block (required)
  if (!block || !block.value.trim()) {
    errors.push('Please enter a block');
  }
  
  // Validate College (required)
  if (!college || !college.value || college.value === '') {
    errors.push('Please select a college');
  }
  
  // Validate Start Date (required)
  if (!dateStart || !dateStart.value) {
    errors.push('Please select a start date and time');
  }
  
  // Validate End Date (required)
  if (!dateEnd || !dateEnd.value) {
    errors.push('Please select an end date and time');
  }
  
  // Validate date range (end must be after start)
  if (dateStart && dateStart.value && dateEnd && dateEnd.value) {
    var startDate = new Date(dateStart.value);
    var endDate = new Date(dateEnd.value);
    if (endDate <= startDate) {
      errors.push('End date must be after start date');
    }
  }
  
  // Check if PC quantity is selected (required)
  var pcQty = 0;
  if (customNumOfPc && parseInt(customNumOfPc.value) > 0) {
    pcQty = parseInt(customNumOfPc.value);
    if (custNumOfPc) {
      custNumOfPc.value = pcQty;
    }
  } else if (custNumOfPc && parseInt(custNumOfPc.value) > 0) {
    pcQty = parseInt(custNumOfPc.value);
  } else if (numOfPc && parseInt(numOfPc.value) > 0) {
    pcQty = parseInt(numOfPc.value);
  }
  
  if (pcQty <= 0) {
    errors.push('Please select the number of PCs needed from the PC selection modal');
  } else if (pcQty < 2) {
    errors.push('Minimum booking is 2 PCs. Please add more PCs to continue.');
  }
  
  // Validate email list
  var emailList = document.getElementById('emailList');
  if (!emailList || !emailList.value.trim()) {
    errors.push('Please enter at least one student email address');
  } else {
    var input = emailList.value;
    var emails = input.split(',').map(e => e.trim()).filter(e => e.length > 0);
    var emailPattern = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    var allValid = emails.length > 0 && emails.every(email => emailPattern.test(email));
    
    if (!allValid) {
      errors.push('Please enter valid email addresses. All emails must be in the correct format.');
    }
  }
  
  // If there are errors, show them
  if (errors.length > 0) {
    var errorMessage = 'Please fix the following errors before submitting:\n\n' + errors.join('\n');
    alert(errorMessage);
    return false;
  }
  
  // All validations passed, submit the form
  var form = document.getElementById('facultyForm');
  if (form) {
    console.log('All validations passed. Submitting form...');
    // Show loading state
    var submitBtn = document.getElementById('step2SubmitBtn');
    if (submitBtn) {
      submitBtn.disabled = true;
      submitBtn.innerHTML = '<i class="fa-solid fa-spinner fa-spin me-2"></i> Submitting...';
    }
    form.submit();
  } else {
    alert('Form not found. Please refresh the page and try again.');
    return false;
  }
  
  return false;
};

// Function to advance to next step in the form
window.advanceStep = function advanceStep(currentStep, nextStep) {
  console.log('Advancing from', currentStep, 'to', nextStep);
  var currentStepDiv = document.getElementById(currentStep);
  var nextStepDiv = document.getElementById(nextStep);
  
  console.log('Step elements:', {
    currentStep: !!currentStepDiv,
    nextStep: !!nextStepDiv
  });
  
  if (currentStepDiv) {
    currentStepDiv.classList.remove('active');
    console.log('Removed active from', currentStep);
  } else {
    console.error('Current step not found:', currentStep);
  }
  
  if (nextStepDiv) {
    nextStepDiv.classList.add('active');
    console.log('Added active to', nextStep);
    // Force display in case CSS isn't working
    nextStepDiv.style.display = 'block';
  } else {
    console.error('Next step not found:', nextStep);
  }

  var formSection = document.getElementById('faculty-form-section');
  if (formSection) {
    formSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
  }
  
  console.log('Step transition complete');
}

// Function to go back to the previous step in the form
function goBackStep(currentStep, previousStep) {
  console.log('Going back from', currentStep, 'to', previousStep);
  var currentStepDiv = document.getElementById(currentStep);
  var previousStepDiv = document.getElementById(previousStep);

  if (currentStepDiv) {
    currentStepDiv.classList.remove('active');
  }

  if (previousStepDiv) {
    previousStepDiv.classList.add('active');
  }

  if (previousStep === 'step2') {
    var emailList = document.getElementById('emailList');
    if (emailList) {
      validateEmailList(emailList);
    }
  }

  var formSection = document.getElementById('faculty-form-section');
  if (formSection) {
    formSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
  }
}

// Return to PC selection screen from faculty form
window.backToPcSelection = function backToPcSelection() {
  console.log('Returning to PC selection');
  var facultyFormSection = document.getElementById('faculty-form-section');
  var step3NextBtn = document.getElementById('step3NextBtn');
  var legendAndControl = document.getElementById('legend-and-control');

  // Hide the faculty form section
  if (facultyFormSection) {
    facultyFormSection.setAttribute('hidden', 'true');
    facultyFormSection.style.display = 'none';
    // Reset all steps to initial state
    var steps = facultyFormSection.querySelectorAll('.step');
    steps.forEach(function(step, index) {
      if (index === 0) {
        step.classList.add('active');
      } else {
        step.classList.remove('active');
      }
    });
  }

  // Show legend and control section
  if (legendAndControl) {
    legendAndControl.removeAttribute('hidden');
    legendAndControl.style.display = '';
  }

  // Show the PC selection modal again
  var pcSelectionModal = document.getElementById('pcSelectionModal');
  if (pcSelectionModal && typeof bootstrap !== 'undefined') {
    // Get existing modal instance or create new one
    var modalInstance = bootstrap.Modal.getInstance(pcSelectionModal);
    if (modalInstance) {
      modalInstance.show();
    } else {
      var modal = new bootstrap.Modal(pcSelectionModal, {
        backdrop: true,
        keyboard: true
      });
      modal.show();
    }
  } else {
    console.error('PC Selection Modal not found or Bootstrap not available');
  }

  var step2SubmitBtn = document.getElementById('step2SubmitBtn');
  if (step2SubmitBtn) {
    step2SubmitBtn.hidden = true;
  }

  // Reset PC group button selections
  var pcGroupButtons = document.querySelectorAll('.pc-group-number');
  pcGroupButtons.forEach(function(btn) {
    btn.disabled = false;
    btn.classList.remove('bg-warning');
  });

  // Reset custom PC input
  var customInput = document.getElementById('customNumOfPc');
  if (customInput) {
    customInput.value = 2;
  }
  var custNumOfPcHidden = document.getElementById('custNumOfPc');
  if (custNumOfPcHidden) {
    custNumOfPcHidden.value = '';
  }
  var numOfPc = document.getElementById('numOfPc');
  if (numOfPc) {
    numOfPc.value = '';
  }

  // Hide the block-button-next
  var blockButtonNext = document.getElementById('block-button-next');
  if (blockButtonNext) {
    blockButtonNext.hidden = true;
  }

  var blockButton = document.getElementById('block-button');
  if (blockButton) {
    blockButton.removeAttribute('hidden');
    blockButton.style.display = '';
  }
  
  console.log('Returned to PC selection');
}

document.addEventListener('DOMContentLoaded', function() {
  console.log("Reserve PC page loaded");
  
  // Add real-time validation - clear invalid state when user starts typing/selecting
  var course = document.getElementById('course');
  var block = document.getElementById('block');
  var college = document.getElementById('college');
  var dateStart = document.getElementById('dateStart');
  var dateEnd = document.getElementById('dateEnd');
  
  if (course) {
    course.addEventListener('input', function() {
      if (this.value.trim()) {
        this.classList.remove('is-invalid');
      }
    });
  }
  
  if (block) {
    block.addEventListener('input', function() {
      if (this.value.trim()) {
        this.classList.remove('is-invalid');
      }
    });
  }
  
  if (college) {
    college.addEventListener('change', function() {
      if (this.value && this.value !== '') {
        this.classList.remove('is-invalid');
      }
    });
  }
  
  if (dateStart) {
    dateStart.addEventListener('change', function() {
      if (this.value) {
        this.classList.remove('is-invalid');
        // Also validate date range if end date is set
        if (dateEnd && dateEnd.value) {
          var start = new Date(this.value);
          var end = new Date(dateEnd.value);
          if (end > start) {
            dateEnd.classList.remove('is-invalid');
          }
        }
      }
    });
  }
  
  if (dateEnd) {
    dateEnd.addEventListener('change', function() {
      if (this.value) {
        // Validate date range
        if (dateStart && dateStart.value) {
          var start = new Date(dateStart.value);
          var end = new Date(this.value);
          if (end > start) {
            this.classList.remove('is-invalid');
          }
        } else {
          this.classList.remove('is-invalid');
        }
      }
    });
  }
  
  // Add event listener for step1 Back button as backup
  var step1BackBtn = document.getElementById('step1BackBtn');
  if (step1BackBtn) {
    step1BackBtn.addEventListener('click', function(e) {
      e.preventDefault();
      e.stopPropagation();
      console.log('Step1 Back button clicked via event listener');
      if (typeof window.backToPcSelection === 'function') {
        window.backToPcSelection();
      } else {
        console.error('backToPcSelection function not found');
      }
      return false;
    });
  }
  
  // Global handler to ensure reservation-body stays visible when any modal closes
  // Make it globally accessible
  window.ensureReservationBodyVisible = function() {
    // Ensure reservation-body and all parent containers are visible
    var reservationBody = document.querySelector('.reservation-body');
    if (reservationBody) {
      // Force visibility on the element itself
      reservationBody.style.display = '';
      reservationBody.style.visibility = 'visible';
      reservationBody.style.opacity = '1';
      reservationBody.removeAttribute('hidden');
      reservationBody.hidden = false;
      
      // Also ensure parent containers are visible
      var reservationCard = reservationBody.closest('.reservation-card');
      if (reservationCard) {
        reservationCard.style.display = '';
        reservationCard.style.visibility = 'visible';
        reservationCard.removeAttribute('hidden');
        reservationCard.hidden = false;
      }
      
      var mobileContainer = reservationBody.closest('.mobile-reservation-container');
      if (mobileContainer) {
        mobileContainer.style.display = '';
        mobileContainer.style.visibility = 'visible';
        mobileContainer.removeAttribute('hidden');
        mobileContainer.hidden = false;
      }
      
      console.log('Ensured reservation-body and parent containers are visible');
    }
    
    // Also ensure students-booking is visible
    var studentsBooking = document.getElementById('students-booking');
    if (studentsBooking) {
      studentsBooking.style.display = '';
      studentsBooking.style.visibility = 'visible';
      studentsBooking.removeAttribute('hidden');
      studentsBooking.hidden = false;
    }
  };
  
  // Alias for easier access
  var ensureReservationBodyVisible = window.ensureReservationBodyVisible;
  
  // Listen to all modal close events
  document.addEventListener('hidden.bs.modal', function(event) {
    console.log('Modal closed:', event.target.id);
    // Use setTimeout to ensure this runs after Bootstrap's cleanup
    setTimeout(ensureReservationBodyVisible, 100);
  }, true); // Use capture phase to catch all modal close events
  
  // Also listen for when modal backdrop is removed
  var observer = new MutationObserver(function(mutations) {
    mutations.forEach(function(mutation) {
      if (mutation.type === 'childList') {
        var removedNodes = Array.from(mutation.removedNodes);
        var backdropRemoved = removedNodes.some(function(node) {
          return node.nodeType === 1 && node.classList && node.classList.contains('modal-backdrop');
        });
        if (backdropRemoved) {
          console.log('Modal backdrop removed, ensuring reservation-body is visible');
          setTimeout(ensureReservationBodyVisible, 50);
        }
      }
    });
  });
  
  // Observe body for backdrop removal
  if (document.body) {
    observer.observe(document.body, {
      childList: true,
      subtree: false
    });
  }
  
  // Periodic check as fallback - ensure reservation-body is visible every 500ms
  // This catches any edge cases where the event handlers might miss something
  setInterval(function() {
    var reservationBody = document.querySelector('.reservation-body');
    if (reservationBody) {
      var computedStyle = window.getComputedStyle(reservationBody);
      var isHidden = reservationBody.hidden || 
                     reservationBody.hasAttribute('hidden') ||
                     computedStyle.display === 'none' ||
                     computedStyle.visibility === 'hidden' ||
                     computedStyle.opacity === '0';
      
      if (isHidden) {
        console.warn('Reservation-body was hidden, restoring visibility');
        ensureReservationBodyVisible();
      }
    }
  }, 500);

  // Also add event listener for Cancel button as backup
  var cancelButton = document.getElementById('pc-selection-cancel-btn');
  if (cancelButton) {
    cancelButton.addEventListener('click', function(e) {
      e.preventDefault();
      e.stopPropagation();
      console.log('Cancel button clicked via event listener');
      if (typeof window.closeModalAndScrollToReservation === 'function') {
        window.closeModalAndScrollToReservation();
      } else {
        console.error('closeModalAndScrollToReservation function not found');
      }
    });
  } else {
    console.warn('Cancel button not found');
  }

  // Handle PC selection modal close - restore PC list visibility
  var pcSelectionModal = document.getElementById('pcSelectionModal');
  if (pcSelectionModal && typeof bootstrap !== 'undefined') {
    pcSelectionModal.addEventListener('hidden.bs.modal', function() {
      console.log('PC selection modal closed - restoring PC list');
      
      // Ensure reservation-body is visible
      setTimeout(ensureReservationBodyVisible, 100);
      
      // Show the students booking section and legend again using jQuery for consistency
      if (typeof jQuery !== 'undefined' && typeof $ !== 'undefined') {
        $("#students-booking").show();
        $("#legend").show();
        $("#block-button").show().prop("hidden", false);
      } else {
        // Fallback to vanilla JS
        var studentsBooking = document.getElementById('students-booking');
        var legend = document.getElementById('legend');
        var blockButton = document.getElementById('block-button');
        
        if (studentsBooking) {
          studentsBooking.style.display = '';
          studentsBooking.removeAttribute('hidden');
        }
        
        if (legend) {
          legend.style.display = '';
          legend.removeAttribute('hidden');
        }
        
        if (blockButton) {
          blockButton.style.display = '';
          blockButton.removeAttribute('hidden');
          blockButton.hidden = false;
        }
      }
      
      // Reset PC selection in modal
      var pcGroupButtons = document.querySelectorAll('.pc-group-number');
      pcGroupButtons.forEach(function(btn) {
        btn.disabled = false;
        btn.classList.remove('bg-warning');
      });
      
      var customInput = document.getElementById('customNumOfPc');
      if (customInput) {
        customInput.value = 0;
      }
      
      var blockButtonNext = document.getElementById('block-button-next');
      if (blockButtonNext) {
        blockButtonNext.hidden = true;
        blockButtonNext.setAttribute('hidden', 'true');
      }
      
      // Clear any error messages
      var errorMsg = document.getElementById('pc-limit-error');
      if (errorMsg) {
        errorMsg.style.display = 'none';
      }
    });
  }
  
  // Ensure offline/repair PCs are always disabled and unclickable
  // Also ensure used/queued PCs are clickable
  document.querySelectorAll('.pc-button-modern, .pc-button').forEach(function(button) {
    const pcStatus = button.getAttribute('data-pc-status');
    const pcCondition = button.getAttribute('data-pc-condition');
    const pcBookingStatus = button.getAttribute('data-booking-status');
    
    if (pcCondition === 'repair' || pcStatus === 'disconnected') {
      button.disabled = true;
      button.style.pointerEvents = 'none';
      button.style.cursor = 'not-allowed';
      button.style.opacity = '0.6';
      button.setAttribute('tabindex', '-1');
      
      // Remove any click handlers that might bypass disabled state
      button.onclick = function(e) {
        e.preventDefault();
        e.stopPropagation();
        showPCStatus(parseInt(button.getAttribute('data-pc-id')), button);
        return false;
      };
     } else if (pcBookingStatus === 'in_use' || pcBookingStatus === 'in_queue') {
       // Make sure used/queued PCs are clickable (not disabled) to show status
       button.disabled = false;
       button.style.pointerEvents = 'auto';
       button.style.cursor = 'pointer';
       button.style.opacity = '1';
       
       // Ensure onclick handler is set
       if (!button.onclick || button.onclick.toString().indexOf('showPCStatus') === -1) {
         button.onclick = function(e) {
           e.preventDefault();
           e.stopPropagation();
           showPCStatus(parseInt(button.getAttribute('data-pc-id')), button);
           return false;
         };
       }
     } else {
       // Available PC - check if user has active booking (student or faculty)
       if (window.__hasActiveBooking || window.__hasActiveFacultyBooking) {
         button.disabled = true;
         button.style.cursor = 'not-allowed';
         button.style.opacity = '0.6';
         button.style.pointerEvents = 'none';
         button.onclick = function() {
           return false;
         };
       } else {
         button.disabled = false;
         button.style.cursor = 'pointer';
         button.style.opacity = '1';
         button.style.pointerEvents = 'auto';
       }
     }
  });
  
  // Check if any PCs exist
  var pcButtons = document.querySelectorAll('.pc-button');
  console.log("Found PC buttons:", pcButtons.length);
  
  // Check if hidden field exists
  var pcIdInput = document.getElementById('pc_id');
  if (!pcIdInput) {
    console.warn("Warning: pc_id input field not found!");
  }
  
  // Add event listeners for PC group buttons
  var pcGroupButtons = document.querySelectorAll('.pc-group-number');
  pcGroupButtons.forEach(function(button) {
    button.addEventListener('click', function() {
      handlePcGroupClick(button);
    });
  });
  
  // Add event listener for block button next
  var blockButtonNext = document.getElementById('block-button-next');
  if (blockButtonNext) {
    blockButtonNext.addEventListener('click', goToBlockBookingForm);
  }
  
  // Ensure Next button starts disabled and visible
  var nextButtonInit = document.querySelector('.reserve-next-button');
  if (nextButtonInit) {
    nextButtonInit.disabled = true;
    nextButtonInit.setAttribute('aria-disabled', 'true');
    nextButtonInit.style.display = 'block';
    nextButtonInit.style.visibility = 'visible';
  }
  
  // Add event listeners for custom PC input +/- buttons
  var fbPlusBtn = document.getElementById('fb-plusBtn');
  var fbMinusBtn = document.getElementById('fb-minusBtn');
  var customNumOfPc = document.getElementById('customNumOfPc');
  
  if (fbPlusBtn) {
    fbPlusBtn.addEventListener('click', incrementCustomPc);
  }
  
  if (fbMinusBtn) {
    fbMinusBtn.addEventListener('click', decrementCustomPc);
  }
  
  if (customNumOfPc) {
    customNumOfPc.addEventListener('input', handleCustomPcInput);
  }
  
  // Add click handler for Next button to show modal
  var nextButton = document.querySelector('.reserve-next-button');
  if (nextButton) {
    nextButton.addEventListener('click', function() {
      console.log('Next button clicked, showing duration modal');
      var durationModal = document.getElementById('durationModal');
      if (durationModal) {
        // Use Bootstrap 5 modal API
        if (typeof bootstrap !== 'undefined' && bootstrap.Modal) {
          var modal = new bootstrap.Modal(durationModal);
          modal.show();
        } else {
          // Fallback if bootstrap not loaded
          durationModal.style.display = 'block';
          durationModal.classList.add('show');
        }
      } else {
        console.error('Duration modal not found!');
      }
    });
  }
  
  // Helper function to convert time string (HH:MM:SS) to total seconds
  function timeToSeconds(timeStr) {
    var parts = timeStr.split(':');
    var hours = parseInt(parts[0]) || 0;
    var minutes = parseInt(parts[1]) || 0;
    var seconds = parseInt(parts[2]) || 0;
    return hours * 3600 + minutes * 60 + seconds;
  }
  
  // Helper function to convert total seconds to time string (HH:MM:SS)
  function secondsToTime(totalSeconds) {
    totalSeconds = Math.max(0, Math.min(totalSeconds, 10800)); // Max 3 hours (10800 seconds)
    var hours = Math.floor(totalSeconds / 3600);
    var minutes = Math.floor((totalSeconds % 3600) / 60);
    var seconds = totalSeconds % 60;
    return String(hours).padStart(2, '0') + ':' + 
           String(minutes).padStart(2, '0') + ':' + 
           String(seconds).padStart(2, '0');
  }
  
  // Helper function to convert time string to minutes (for backend)
  function timeToMinutes(timeStr) {
    var totalSeconds = timeToSeconds(timeStr);
    return Math.floor(totalSeconds / 60);
  }
  
  // Add handlers for duration +/- buttons
  var plusBtn = document.getElementById('plusBtn');
  var minusBtn = document.getElementById('minusBtn');
  var durationInput = document.getElementById('durationInput');
  
  // Format time input on change to ensure HH:MM:SS format
  if (durationInput) {
    durationInput.addEventListener('blur', function() {
      var value = this.value;
      if (value) {
        // Validate and format the time
        var parts = value.split(':');
        if (parts.length === 3) {
          var hours = Math.min(parseInt(parts[0]) || 0, 3); // Max 3 hours
          var minutes = Math.min(parseInt(parts[1]) || 0, 59);
          var seconds = Math.min(parseInt(parts[2]) || 0, 59);
          
          // Ensure total doesn't exceed 3 hours
          var totalSeconds = hours * 3600 + minutes * 60 + seconds;
          if (totalSeconds > 10800) {
            totalSeconds = 10800;
            hours = 3;
            minutes = 0;
            seconds = 0;
          }
          
          // Ensure minimum is 1 minute (60 seconds) to prevent 0 duration
          if (totalSeconds < 60) {
            totalSeconds = 60;
            hours = 0;
            minutes = 1;
            seconds = 0;
          }
          
          this.value = String(hours).padStart(2, '0') + ':' + 
                      String(minutes).padStart(2, '0') + ':' + 
                      String(seconds).padStart(2, '0');
        } else {
          // If format is wrong, reset to default (5 minutes)
          this.value = '00:05:00';
        }
      }
    });
    
    durationInput.addEventListener('input', function() {
      // Auto-format as user types
      var value = this.value.replace(/[^\d:]/g, ''); // Remove non-digit, non-colon characters
      this.value = value;
    });
  }
  
  if (plusBtn && durationInput) {
    plusBtn.addEventListener('click', function() {
      var currentTime = durationInput.value || '00:00:00';
      var currentSeconds = timeToSeconds(currentTime);
      var newSeconds = Math.min(currentSeconds + 300, 10800); // Add 5 minutes (300 seconds), max 3 hours
      var newTime = secondsToTime(newSeconds);
      durationInput.value = newTime;
      console.log('Duration increased to:', newTime);
      
      // Disable plus button if at max (3 hours)
      if (newSeconds >= 10800) {
        plusBtn.disabled = true;
      }
      // Enable minus button
      if (minusBtn) minusBtn.disabled = false;
    });
  }
  
  if (minusBtn && durationInput) {
    minusBtn.addEventListener('click', function() {
      var currentTime = durationInput.value || '00:05:00';
      var currentSeconds = timeToSeconds(currentTime);
      var newSeconds = Math.max(currentSeconds - 300, 300); // Subtract 5 minutes (300 seconds), min 5 minutes (300 seconds)
      var newTime = secondsToTime(newSeconds);
      durationInput.value = newTime;
      console.log('Duration decreased to:', newTime);
      
      // Disable minus button if at min (5 minutes)
      if (newSeconds <= 300) {
        minusBtn.disabled = true;
      }
      // Enable plus button
      if (plusBtn) plusBtn.disabled = false;
    });
  }
  
  // Add handler for Generate QR Code button
  var generateQRBtn = document.getElementById('generate-qr-button');
  if (generateQRBtn) {
    generateQRBtn.addEventListener('click', function() {
      console.log('Generate QR Code button clicked');
      var timeValue = durationInput ? durationInput.value : null;
      var selectedPC = document.getElementById('pc_id') ? document.getElementById('pc_id').value : null;
      
      console.log('Time value:', timeValue, 'PC:', selectedPC);
      
      // Validate time input
      if (!timeValue || timeValue === '00:00:00') {
        alert("Please enter a valid time duration.");
        return;
      }
      
      // Check if time exceeds 3 hours
      var totalSeconds = timeToSeconds(timeValue);
      if (totalSeconds > 10800) { // 3 hours = 10800 seconds
        alert("Maximum booking duration is 3 hours (03:00:00).");
        return;
      }
      
      // Convert time to minutes for backend
      var duration = timeToMinutes(timeValue);
      
      // Check if duration is valid (greater than 0)
      if (duration <= 0) {
        alert("Please enter a valid duration (must be greater than 0).");
        return;
      }
      
      if (!selectedPC) {
        alert("Please select a PC first.");
        return;
      }
      
      // Validate PC status - check if selected PC is offline or in repair
      var selectedButton = document.querySelector('.pc-button.text-success');
      if (selectedButton) {
        var pcStatus = selectedButton.getAttribute('data-pc-status');
        var pcCondition = selectedButton.getAttribute('data-pc-condition');
        var pcBookingStatus = selectedButton.getAttribute('data-booking-status');
        var pcName = selectedButton.getAttribute('data-pc-name');
        
        if (pcCondition === 'repair') {
          alert(`PC ${pcName} is currently in repair and cannot be reserved.\n\nPlease select a different PC.`);
          return;
        }
        
        if (pcStatus === 'disconnected') {
          alert(`PC ${pcName} is currently offline and cannot be reserved.\n\nPlease select a different PC.`);
          return;
        }
        
        if (pcBookingStatus === 'in_use' || pcBookingStatus === 'in_queue') {
          alert(`PC ${pcName} is currently ${pcBookingStatus.replace('_', ' ')} and cannot be reserved.\n\nPlease select a different PC.`);
          return;
        }
      }
      
      var reserveUrl = generateQRBtn.getAttribute('data-reserve-url') || '/reserve-pc/';
      console.log('Sending request to:', reserveUrl);
      
      // Show loading state
      generateQRBtn.disabled = true;
      generateQRBtn.textContent = 'Generating...';
      
      // Send AJAX request with form data
      var formData = new URLSearchParams();
      formData.append('pc_id', selectedPC);
      formData.append('duration', duration); // Send duration in minutes to backend
      
      fetch(reserveUrl, {
        method: 'POST',
        headers: {
          'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]')?.value || ''
        },
        body: formData
      })
      .then(response => {
        console.log('Response status:', response.status);
        console.log('Response headers:', response.headers.get('content-type'));
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        return response.json();
      })
      .then(data => {
        console.log('Response received:', data);
        
        if (!data.success) {
          alert('Error: ' + (data.error || 'Unknown error'));
          return;
        }
        
        // Immediately update the selected PC button to show "in_queue" status (yellow)
        var selectedButton = document.querySelector('.pc-button-modern.pc-selected, .pc-button-modern.selected, .pc-button.text-success');
        if (selectedButton) {
          // Remove selected classes
          selectedButton.classList.remove('pc-selected', 'selected', 'text-success');
          // Update booking status attribute
          selectedButton.setAttribute('data-booking-status', 'in_queue');
          // Update visual classes - remove all status classes and add queue
          selectedButton.classList.remove('pc-available', 'pc-used', 'pc-queue');
          selectedButton.classList.add('pc-queue');
          // Make sure it's clickable to show status
          selectedButton.disabled = false;
          selectedButton.style.cursor = 'pointer';
          selectedButton.style.opacity = '1';
          selectedButton.style.pointerEvents = 'auto';
          // Update onclick handler
          var pcId = selectedButton.getAttribute('data-pc-id');
          selectedButton.onclick = function() {
            if (typeof showPCStatus === 'function') {
              showPCStatus(pcId, selectedButton);
            }
            return false;
          };
        }
        
        // Hide duration modal
        var durationModal = document.getElementById('durationModal');
        if (durationModal && typeof bootstrap !== 'undefined') {
          var modal = bootstrap.Modal.getInstance(durationModal);
          if (modal) modal.hide();
        }
        
        // Immediately refresh PC status to show updated status
        if (typeof window.refreshPCStatusForReservation === 'function') {
          window.refreshPCStatusForReservation();
        }
        
        // Show QR code modal
        var qrModal = document.getElementById('qrModal');
        var qrImage = document.getElementById('qrImage');
        var bookingIdSpan = document.getElementById('booking_id');
        var qrCountdown = document.getElementById('qrCountdown');
        
        // Set QR code image
        if (qrImage && data.qr_code) {
          var qrImageData = 'data:image/png;base64,' + data.qr_code;
          qrImage.src = qrImageData;
          console.log('QR code image set');
          
          // Store QR code data globally and in localStorage for persistence
          window.storedQRCode = qrImageData;
          window.storedBookingId = data.booking_id;
          
          // Get PC ID
          var pcIdFromForm = document.getElementById('pc_id');
          window.storedPCId = pcIdFromForm ? pcIdFromForm.value : null;
          
          // Store in localStorage for persistence after refresh
          try {
            localStorage.setItem('qrCodeData', qrImageData);
            localStorage.setItem('qrBookingId', String(data.booking_id));
            localStorage.setItem('qrPCId', window.storedPCId || '');
            localStorage.setItem('qrCodeTimestamp', String(Date.now()));
          } catch (e) {
            console.error('Error saving to localStorage:', e);
          }
          
          // Show the "My Session" button (replaces View QR Code button)
          var viewQRContainer = document.getElementById('viewQRButtonContainer');
          if (viewQRContainer) {
            viewQRContainer.style.display = 'block';
            viewQRContainer.style.visibility = 'visible';
            viewQRContainer.style.opacity = '1';
          }
          // Also check for active session to ensure button shows - check immediately and after delay
          checkMyActiveSession();
          setTimeout(function() {
            checkMyActiveSession();
          }, 500);
          setTimeout(function() {
            checkMyActiveSession();
          }, 2000);
          
          // Start auto-refresh checker for QR code scanning immediately after generation
          if (data.booking_id) {
            console.log('Starting QR approval checker (vanilla) for booking ID:', data.booking_id);
            if (typeof startQRApprovalCheckerVanilla === 'function') {
              startQRApprovalCheckerVanilla(data.booking_id);
            } else {
              console.warn('startQRApprovalCheckerVanilla function not found');
            }
          }
        }
        
        // Set booking ID
        if (bookingIdSpan && data.booking_id) {
          bookingIdSpan.textContent = data.booking_id;
          console.log('Booking ID set:', data.booking_id);
        }
        
        // Check for active session to show button after booking is created
        setTimeout(function() {
          checkMyActiveSession();
        }, 500);
        
        // Store PC ID for cancel functionality
        var pcIdInput = document.getElementById('qr_booking_pc_id');
        var pcIdFromForm = document.getElementById('pc_id');
        if (pcIdInput && pcIdFromForm && pcIdFromForm.value) {
          pcIdInput.value = pcIdFromForm.value;
        }
        
        // Start countdown timer (10 minutes = 600 seconds)
        var countdownSeconds = 600;
        var countdownInterval;
        
        // Store intervals globally so we can clear them when canceling
        window.qrCountdownInterval = null;
        window.qrApprovalChecker = null;
        window.qrCountdownSeconds = 600; // Store countdown seconds
        window.qrModalPaused = false; // Track if modal is paused
        
        function updateCountdown() {
          // Skip if paused
          if (window.qrModalPaused) {
            return;
          }
          
          var minutes = Math.floor(countdownSeconds / 60);
          var seconds = countdownSeconds % 60;
          var displayTime = minutes.toString().padStart(2, '0') + ':' + seconds.toString().padStart(2, '0');
          
          if (qrCountdown) {
            qrCountdown.textContent = displayTime;
          }
          
          countdownSeconds--;
          window.qrCountdownSeconds = countdownSeconds; // Store current value
          
          if (countdownSeconds < 0) {
            clearInterval(countdownInterval);
            window.qrCountdownInterval = null;
            if (qrCountdown) qrCountdown.textContent = '00:00';
            
            // Clear intervals
            if (window.qrApprovalChecker) {
              clearInterval(window.qrApprovalChecker);
              window.qrApprovalChecker = null;
            }
            
            // Auto-close modal
            if (qrModal && typeof bootstrap !== 'undefined') {
              var modal = bootstrap.Modal.getInstance(qrModal);
              if (modal) modal.hide();
            }
            
            // Hide View QR button when expired
            var viewQRContainer = document.getElementById('viewQRButtonContainer');
            if (viewQRContainer) {
              viewQRContainer.style.display = 'none';
            }
          }
        }
        
        // Start countdown
        updateCountdown();
        countdownInterval = setInterval(updateCountdown, 1000);
        window.qrCountdownInterval = countdownInterval; // Store globally
        window.qrModalPaused = false; // Ensure not paused
        console.log('Countdown started');
        
        // Show QR modal
        if (qrModal && typeof bootstrap !== 'undefined') {
          var modal = new bootstrap.Modal(qrModal);
          modal.show();
          console.log('QR modal shown');
        }
        
        // Check for approval periodically
        var bookingId = data.booking_id;
        var approvalChecker = setInterval(function() {
          // Skip if paused
          if (window.qrModalPaused) {
            return;
          }
          
          if (!bookingId) return;
          
          fetch(`/ajax/waiting-approval/${bookingId}`)
            .then(response => response.json())
            .then(function(approvalData) {
              if (approvalData.status === 'confirmed') {
                clearInterval(approvalChecker);
                clearInterval(countdownInterval);
                window.qrCountdownInterval = null;
                window.qrApprovalChecker = null;
                console.log('Approval detected. QR expiration timer stopped.');
                
                // Clear QR code data (one-time use)
                try {
                  localStorage.removeItem('qrCodeData');
                  localStorage.removeItem('qrBookingId');
                  localStorage.removeItem('qrPCId');
                  localStorage.removeItem('qrCodeTimestamp');
                  window.storedQRCode = null;
                  window.storedBookingId = null;
                  window.storedPCId = null;
                } catch (e) {
                  console.error('Error clearing QR code data:', e);
                }
                
                // Hide QR modal
                if (qrModal && typeof bootstrap !== 'undefined') {
                  var modal = bootstrap.Modal.getInstance(qrModal);
                  if (modal) modal.hide();
                }
                
                // Show "My Session" modal instead of timeRemainingModal
                // Get booking ID from approval data
                var bookingId = approvalData.booking_id;
                var bookingIdEl = document.getElementById('booking_id');
                if (bookingId && bookingIdEl) {
                  bookingIdEl.textContent = bookingId;
                }
                
                // Store booking ID globally for end session button
                if (bookingId) {
                  window.currentBookingId = bookingId;
                }
                
                // Immediately check for active session to show button
                checkMyActiveSession();
                
                // Show the "My Session" modal after a short delay to ensure data is loaded
                setTimeout(function() {
                  showMySessionModal();
                }, 500);
                
                // Also check again after a short delay to ensure button shows
                setTimeout(function() {
                  checkMyActiveSession();
                }, 1000);
              } else if (approvalData.status === 'cancelled') {
                // Clear QR code data (one-time use)
                try {
                  localStorage.removeItem('qrCodeData');
                  localStorage.removeItem('qrBookingId');
                  localStorage.removeItem('qrPCId');
                  localStorage.removeItem('qrCodeTimestamp');
                  window.storedQRCode = null;
                  window.storedBookingId = null;
                  window.storedPCId = null;
                } catch (e) {
                  console.error('Error clearing QR code data:', e);
                }
                clearInterval(approvalChecker);
                clearInterval(countdownInterval);
                window.qrCountdownInterval = null;
                window.qrApprovalChecker = null;
                console.log('Reservation cancelled. QR expiration timer stopped.');
                
                // Clear stored QR code data
                window.storedQRCode = null;
                window.storedBookingId = null;
                window.storedPCId = null;
                
                // Clear localStorage
                try {
                  localStorage.removeItem('qrCodeData');
                  localStorage.removeItem('qrBookingId');
                  localStorage.removeItem('qrPCId');
                  localStorage.removeItem('qrCodeTimestamp');
                } catch (e) {
                  console.error('Error clearing localStorage:', e);
                }
                
                // Hide QR modal and View QR button
                if (qrModal && typeof bootstrap !== 'undefined') {
                  var modal = bootstrap.Modal.getInstance(qrModal);
                  if (modal) {
                    modal.hide();
                    // Remove backdrop if it exists
                    setTimeout(function() {
                      var backdrop = document.querySelector('.modal-backdrop');
                      if (backdrop) {
                        backdrop.remove();
                      }
                      // Remove modal-open class from body
                      document.body.classList.remove('modal-open');
                      document.body.style.overflow = '';
                      document.body.style.paddingRight = '';
                    }, 100);
                  }
                }
                
                var viewQRContainer = document.getElementById('viewQRButtonContainer');
                if (viewQRContainer) {
                  viewQRContainer.style.display = 'none';
                }
                
                alert('Your reservation has been declined!');
                window.location.href = '/pc-reservation/';
              }
            })
            .catch(function(error) {
              console.error('Error checking approval:', error);
            });
        }, 1000);
        window.qrApprovalChecker = approvalChecker; // Store globally
      })
      .catch(error => {
        console.error('Error:', error);
        console.error('Full error details:', error);
        
        // Try to get more details about the error
        fetch(reserveUrl, {
          method: 'POST',
          headers: {
            'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]')?.value || ''
          },
          body: formData
        })
        .then(response => response.text())
        .then(html => {
          console.error('Server response (HTML):', html.substring(0, 500));
          alert('Error generating QR code. Please check console for details.');
        })
        .catch(err => {
          console.error('Fetch error:', err);
          alert('Error generating QR code: ' + error.message);
        });
      })
      .finally(() => {
        generateQRBtn.disabled = false;
        generateQRBtn.textContent = 'Generate QR Code';
      });
    });
  }
});

// Cancel booking button handler - use event delegation for dynamically added modals
// Wait for jQuery to be available
function initCancelBookingHandler() {
  if (typeof jQuery === 'undefined' && typeof $ === 'undefined') {
    // jQuery not loaded yet, retry after a short delay
    setTimeout(initCancelBookingHandler, 100);
    return;
  }
  
  var $ = jQuery || window.$;
  
  $(document).ready(function() {
    // Use event delegation to handle clicks on dynamically added buttons
    $(document).on('click', '#cancelBookingBtn', function(e) {
    e.preventDefault();
    e.stopPropagation();
    
    // Confirm cancellation
    if (!confirm('Are you sure you want to cancel this booking?')) {
      return;
    }
    
    // Get booking ID - it's stored in the span's textContent
    var bookingId = $('#booking_id').text().trim();
    var pcId = $('#qr_booking_pc_id').val();
    
    console.log('Cancel button clicked. Booking ID:', bookingId, 'PC ID:', pcId);
    
    // Validate that we have at least one identifier
    if (!bookingId && !pcId) {
      alert('Error: No booking information found. Please refresh the page and try again.');
      return;
    }
    
    // Disable button to prevent multiple clicks
    var $btn = $(this);
    var originalHtml = $btn.html();
    $btn.prop('disabled', true);
    $btn.html('<i class="fa-solid fa-spinner fa-spin"></i> Cancelling...');
    
    // Clear intervals
    if (window.qrCountdownInterval) {
      clearInterval(window.qrCountdownInterval);
      window.qrCountdownInterval = null;
    }
    if (window.qrApprovalChecker) {
      clearInterval(window.qrApprovalChecker);
      window.qrApprovalChecker = null;
    }
    
    // Send cancel request
    $.ajax({
      url: '/ajax/cancel-reservation/',
      method: 'POST',
      headers: {
        'X-CSRFToken': (function() {
          var token = $('[name=csrfmiddlewaretoken]').val();
          if (!token) {
            var el = document.querySelector('[name=csrfmiddlewaretoken]');
            token = el ? el.value : '';
          }
          if (!token && typeof getCookie !== 'undefined') {
            token = getCookie('csrftoken') || '';
          }
          return token || '';
        })()
      },
      data: {
        booking_id: bookingId,
        pc_id: pcId
      },
      success: function(response) {
        if (response.success) {
          // Clear stored QR code data
          window.storedQRCode = null;
          window.storedBookingId = null;
          window.storedPCId = null;
          
          // Clear localStorage
          try {
            localStorage.removeItem('qrCodeData');
            localStorage.removeItem('qrBookingId');
            localStorage.removeItem('qrPCId');
            localStorage.removeItem('qrCodeTimestamp');
          } catch (e) {
            console.error('Error clearing localStorage:', e);
          }
          
          // Hide View QR button
          var viewQRContainer = document.getElementById('viewQRButtonContainer');
          if (viewQRContainer) {
            viewQRContainer.style.display = 'none';
          }
          
          // Close QR modal and clean up
          var qrModal = document.getElementById('qrModal');
          if (qrModal && typeof bootstrap !== 'undefined') {
            var modal = bootstrap.Modal.getInstance(qrModal);
            if (modal) {
              modal.hide();
            }
          }
          
          // Remove backdrop and clean up modal state
          setTimeout(function() {
            var backdrop = document.querySelector('.modal-backdrop');
            if (backdrop) {
              backdrop.remove();
            }
            document.body.classList.remove('modal-open');
            document.body.style.overflow = '';
            document.body.style.paddingRight = '';
          }, 100);
          
          // Show success message
          alert(response.message || 'Booking cancelled successfully');
          
          // Reload page to refresh PC status
          location.reload();
        } else {
          alert('Error: ' + (response.error || 'Failed to cancel booking'));
          // Re-enable button on failure
          $btn.prop('disabled', false);
          $btn.html(originalHtml);
        }
      },
      error: function(xhr, status, error) {
        console.error('Cancel booking error:', xhr, status, error);
        console.error('Response text:', xhr.responseText);
        
        // Extract error message from response
        var errorMsg = 'Failed to cancel booking';
        try {
          if (xhr.responseJSON && xhr.responseJSON.error) {
            errorMsg = xhr.responseJSON.error;
          } else if (xhr.responseText) {
            var jsonResponse = JSON.parse(xhr.responseText);
            if (jsonResponse.error) {
              errorMsg = jsonResponse.error;
            }
          }
        } catch (e) {
          // Not JSON, use default message
          console.error('Error parsing response:', e);
        }
        
        alert('Error: ' + errorMsg);
        
        // Re-enable button on error
        $btn.prop('disabled', false);
        $btn.html(originalHtml);
      }
    });
  });
}

// Initialize cancel booking handler when DOM is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initCancelBookingHandler);
} else {
  initCancelBookingHandler();
}
  
  // Helper function to get CSRF cookie
  function getCookie(name) {
    var cookieValue = null;
    if (document.cookie && document.cookie !== '') {
      var cookies = document.cookie.split(';');
      for (var i = 0; i < cookies.length; i++) {
        var cookie = cookies[i].trim();
        if (cookie.substring(0, name.length + 1) === (name + '=')) {
          cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
          break;
        }
      }
    }
    return cookieValue;
  }
  
  // View QR Code button handler
  // Handle My Session button click (replaces View QR Code button)
  // Use vanilla JS instead of jQuery to avoid dependency issues
  var showMySessionBtnMain = document.getElementById('showMySessionBtnMain');
  if (showMySessionBtnMain) {
    showMySessionBtnMain.addEventListener('click', function() {
      showMySessionModal();
    });
  }
  
  // Old viewQRCodeBtn handler - removed, replaced with My Session button
  // This handler is kept for backward compatibility but should not be needed
  var viewQRCodeBtn = document.getElementById('viewQRCodeBtn');
  if (viewQRCodeBtn) {
    viewQRCodeBtn.addEventListener('click', function() {
      // Fallback: reload from localStorage if window vars are missing
      if (!window.storedQRCode) {
        try {
          var storedQR = localStorage.getItem('qrCodeData');
          var storedBookingId = localStorage.getItem('qrBookingId');
          var storedPCId = localStorage.getItem('qrPCId');
          if (storedQR) {
            window.storedQRCode = storedQR;
            window.storedBookingId = storedBookingId;
            window.storedPCId = storedPCId;
          }
        } catch(e) {
          console.error('Error loading QR code from localStorage:', e);
        }
      }
      if (!window.storedQRCode) {
        alert('No QR code found. Please generate a QR code first.');
        return;
      }
      
      // Get references
      var qrModal = document.getElementById('qrModal');
      var qrImage = document.getElementById('qrImage');
      var bookingIdSpan = document.getElementById('booking_id');
      var pcIdInput = document.getElementById('qr_booking_pc_id');
      var qrCountdown = document.getElementById('qrCountdown');
      
      // Restore QR code data
      if (qrImage) {
        qrImage.src = window.storedQRCode;
      }
      
      if (bookingIdSpan && window.storedBookingId) {
        bookingIdSpan.textContent = window.storedBookingId;
      }
      
      if (pcIdInput && window.storedPCId) {
        pcIdInput.value = window.storedPCId;
      }
      
      // Resume countdown if timer is still running
      if (window.qrCountdownInterval && window.qrCountdownSeconds !== undefined && window.qrCountdownSeconds >= 0) {
        window.qrModalPaused = false;
        // Update display with current time
        if (qrCountdown) {
          var minutes = Math.floor(window.qrCountdownSeconds / 60);
          var seconds = window.qrCountdownSeconds % 60;
          var displayTime = minutes.toString().padStart(2, '0') + ':' + seconds.toString().padStart(2, '0');
          qrCountdown.textContent = displayTime;
        }
      } else {
        // No active timer, show static message
        if (qrCountdown) {
          qrCountdown.textContent = 'Viewing saved QR';
        }
      }
      
      // Show the QR modal
      if (qrModal && typeof bootstrap !== 'undefined') {
        var modal = new bootstrap.Modal(qrModal);
        modal.show();
      } else if (window.jQuery && typeof jQuery !== 'undefined') {
        var $ = jQuery || window.$;
        $('#qrModal').modal('show');
      } else if (qrModal) {
        qrModal.style.display = 'block';
        qrModal.classList.add('show');
        document.body.classList.add('modal-open');
      }
    });
  }
  
  // Handle duration modal close event - ensure reservation-body stays visible
  var durationModal = document.getElementById('durationModal');
  if (durationModal) {
    durationModal.addEventListener('hidden.bs.modal', function() {
      console.log('Duration modal closed - ensuring reservation-body is visible');
      setTimeout(ensureReservationBodyVisible, 100);
    });
  }

  // Handle QR modal close event to pause timers and preserve queue status
  var qrModal = document.getElementById('qrModal');
  if (qrModal) {
    qrModal.addEventListener('hidden.bs.modal', function() {
      // Ensure reservation-body is visible
      setTimeout(ensureReservationBodyVisible, 100);
      
      // Pause the timers when modal is closed
      window.qrModalPaused = true;
      console.log('QR modal closed, timers paused');
      
      // Get the PC ID from the form and ensure it stays yellow (in_queue)
      var pcIdInput = document.getElementById('pc_id');
      if (pcIdInput && pcIdInput.value) {
        var pcId = pcIdInput.value;
        // Find the PC button and ensure it shows in_queue status (yellow)
        var pcButton = document.querySelector('.pc-button-modern[data-pc-id="' + pcId + '"]');
        if (pcButton) {
          // Update booking status attribute
          pcButton.setAttribute('data-booking-status', 'in_queue');
          // Remove all status classes
          pcButton.classList.remove('pc-available', 'pc-used', 'pc-selected', 'selected', 'text-success');
          // Add queue class (yellow) - use !important via inline style to override
          pcButton.classList.add('pc-queue');
          // Force yellow color with inline styles to ensure it stays
          pcButton.style.backgroundColor = '#FFF9C4';
          pcButton.style.borderColor = '#FFC107';
          // Make sure it's clickable
          pcButton.disabled = false;
          pcButton.style.cursor = 'pointer';
          pcButton.style.opacity = '1';
          pcButton.style.pointerEvents = 'auto';
          console.log('PC status preserved as in_queue (yellow) after modal close');
          
          // Set a flag to prevent refresh from changing it back
          pcButton.setAttribute('data-preserve-queue', 'true');
        }
      }
      
      // Refresh PC status to ensure consistency (but don't reload page)
      // Use a longer delay to ensure the status is set first
      if (typeof window.refreshPCStatusForReservation === 'function') {
        setTimeout(function() {
          window.refreshPCStatusForReservation();
          // After refresh, ensure queue status is preserved again
          if (pcIdInput && pcIdInput.value) {
            var pcId = pcIdInput.value;
            var pcButton = document.querySelector('.pc-button-modern[data-pc-id="' + pcId + '"]');
            if (pcButton && pcButton.getAttribute('data-preserve-queue') === 'true') {
              pcButton.setAttribute('data-booking-status', 'in_queue');
              pcButton.classList.remove('pc-available', 'pc-used');
              pcButton.classList.add('pc-queue');
              pcButton.style.backgroundColor = '#FFF9C4';
              pcButton.style.borderColor = '#FFC107';
            }
          }
        }, 1000);
      }
    
      // Clean up modal backdrop and body styles
      setTimeout(function() {
        var backdrop = document.querySelector('.modal-backdrop');
        if (backdrop) {
          backdrop.remove();
        }
        document.body.classList.remove('modal-open');
        document.body.style.overflow = '';
        document.body.style.paddingRight = '';
      }, 100);
    });
  }
  
  // Handle QR modal show event to resume timers
  if (qrModal) {
    qrModal.addEventListener('shown.bs.modal', function() {
      // Resume the timers when modal is shown
      if (window.qrCountdownInterval) {
        window.qrModalPaused = false;
        console.log('QR modal shown, timers resumed');
      }
    });
  }
  
  // Load QR code data from localStorage on page load
  function loadStoredQRCode() {
    try {
      var storedQR = localStorage.getItem('qrCodeData');
      var storedBookingId = localStorage.getItem('qrBookingId');
      var storedPCId = localStorage.getItem('qrPCId');
      var storedTimestamp = localStorage.getItem('qrCodeTimestamp');
      
      // Check if QR code is still valid (not expired - 10 minutes = 600000ms)
      if (storedQR && storedBookingId && storedTimestamp) {
        var timestamp = parseInt(storedTimestamp);
        var now = Date.now();
        var tenMinutes = 10 * 60 * 1000; // 10 minutes in milliseconds
        
        // If QR code is older than 10 minutes, remove it
        if (now - timestamp > tenMinutes) {
          localStorage.removeItem('qrCodeData');
          localStorage.removeItem('qrBookingId');
          localStorage.removeItem('qrPCId');
          localStorage.removeItem('qrCodeTimestamp');
          return;
        }
        
        // Restore QR code data
        window.storedQRCode = storedQR;
        window.storedBookingId = storedBookingId;
        window.storedPCId = storedPCId;
        
        // Show the "My Session" button (replaces View QR Code button)
        // But only if there's an active booking
        // Use setTimeout to ensure DOM is ready
        setTimeout(function() {
          checkMyActiveSession();
        }, 100);
        
        console.log('QR code data restored from localStorage');
      }
    } catch (e) {
      console.error('Error loading from localStorage:', e);
    }
  }
  
  // Load stored QR code on page load
  loadStoredQRCode();
});

// Function to check and display student's active session
// Make checkMyActiveSession globally accessible
window.checkMyActiveSession = function() {
  console.log('checkMyActiveSession called');
  
  // Ensure DOM elements exist before proceeding
  var showMySessionBtn = document.getElementById('showMySessionBtn');
  var showMySessionBtnMain = document.getElementById('showMySessionBtnMain');
  var viewQRContainer = document.getElementById('viewQRButtonContainer');
  
  if (!showMySessionBtn && !showMySessionBtnMain && !viewQRContainer) {
    console.warn('My Session button elements not found, retrying in 500ms...');
    setTimeout(checkMyActiveSession, 500);
    return;
  }
  
  fetch('/ajax/get-my-active-booking/')
    .then(response => {
      if (!response.ok) {
        throw new Error('Network response was not ok: ' + response.status);
      }
      return response.json();
    })
    .then(data => {
      console.log('Active booking check result:', data);
      
      // Show/hide "My Session" button based on whether user has an active booking
      // Show button for both confirmed and pending bookings
      // Simplify the condition - show if has_booking is true OR if we have booking data
      var shouldShow = false;
      
      if (data.has_booking === true) {
        shouldShow = true;
        console.log('has_booking is true, showing button');
      } else if (data.booking_id || data.pc_name || data.booking_status !== undefined) {
        // If we have any booking data, show the button
        shouldShow = true;
        console.log('Booking data found, showing button:', {booking_id: data.booking_id, pc_name: data.pc_name, booking_status: data.booking_status});
      } else {
        console.log('No booking data found, hiding button');
      }
      
      if (shouldShow) {
        console.log('User has active booking, showing buttons');
        // Show buttons if user has active booking - use inline-block or flex to ensure visibility
        if (showMySessionBtn) {
          showMySessionBtn.style.display = 'block';
          showMySessionBtn.style.visibility = 'visible';
          showMySessionBtn.style.opacity = '1';
          showMySessionBtn.style.position = 'relative';
          showMySessionBtn.removeAttribute('hidden');
          console.log('Header My Session button shown');
        } else {
          console.warn('showMySessionBtn element not found');
        }
        if (viewQRContainer) {
          viewQRContainer.style.display = 'block';
          viewQRContainer.style.visibility = 'visible';
          viewQRContainer.style.opacity = '1';
          viewQRContainer.removeAttribute('hidden');
          console.log('Main My Session button container shown');
          
          // Start auto-refresh checker for QR code scanning if booking is pending
          if (data.booking_id && data.booking_status !== 'confirmed') {
            startQRApprovalCheckerVanilla(data.booking_id);
          }
        } else {
          console.warn('viewQRContainer element not found');
        }
        if (showMySessionBtnMain) {
          showMySessionBtnMain.style.display = 'block';
          showMySessionBtnMain.style.visibility = 'visible';
          showMySessionBtnMain.style.opacity = '1';
          showMySessionBtnMain.removeAttribute('hidden');
          console.log('Main My Session button shown');
        } else {
          console.warn('showMySessionBtnMain element not found');
        }
      } else {
        console.log('User has no active booking, hiding buttons');
        // Hide buttons if no active booking
        if (showMySessionBtn) {
          showMySessionBtn.style.display = 'none';
          showMySessionBtn.style.visibility = 'hidden';
        }
        if (viewQRContainer) {
          viewQRContainer.style.display = 'none';
          viewQRContainer.style.visibility = 'hidden';
        }
        if (showMySessionBtnMain) {
          showMySessionBtnMain.style.display = 'none';
          showMySessionBtnMain.style.visibility = 'hidden';
        }
        // Clear QR code data if no active booking
        try {
          localStorage.removeItem('qrCodeData');
          localStorage.removeItem('qrBookingId');
          localStorage.removeItem('qrPCId');
          localStorage.removeItem('qrCodeTimestamp');
          window.storedQRCode = null;
          window.storedBookingId = null;
          window.storedPCId = null;
        } catch (e) {
          console.error('Error clearing QR code data:', e);
        }
      }
      
      if (data.has_booking) {
        console.log('Active booking found:', data);
        
        // Store booking_id for end session button - also store in global variable
        var endSessionBtn = document.getElementById('end-session-btn');
        if (endSessionBtn) {
          if (data.booking_id) {
            window.currentBookingId = data.booking_id;
            endSessionBtn.setAttribute('data-booking-id', data.booking_id);
            console.log('Set booking_id on end-session-btn:', data.booking_id);
            console.log('Also stored in window.currentBookingId:', window.currentBookingId);
          } else {
            console.warn('No booking_id in response data:', data);
          }
        } else {
          console.warn('end-session-btn element not found');
        }
        
        // Update modal content
        document.getElementById('session-pc-name').textContent = data.pc_name;
        document.getElementById('session-status').textContent = data.status === 'in_use' ? 'Active' : 'Waiting Approval';
        document.getElementById('session-status').className = data.status === 'in_use' ? 'badge bg-success' : 'badge bg-warning';
        
        if (data.status === 'in_use' && data.time_remaining) {
          // Show time info
          document.getElementById('session-time-info').style.display = 'block';
          document.getElementById('session-waiting').style.display = 'none';
          document.getElementById('session-time-left').textContent = data.time_remaining;
          
          // Set booking_id BEFORE showing the button
          var endSessionBtn = document.getElementById('end-session-btn');
          if (endSessionBtn && data.booking_id) {
            // Store booking_id in both places for reliability
            window.currentBookingId = data.booking_id;
            endSessionBtn.setAttribute('data-booking-id', data.booking_id);
            console.log('Set booking_id on end-session-btn before showing:', data.booking_id);
            console.log('Stored in window.currentBookingId:', window.currentBookingId);
            console.log('Button data-booking-id attribute:', endSessionBtn.getAttribute('data-booking-id'));
            
            // Set onclick handler directly
            endSessionBtn.onclick = window.handleEndSession;
            
            endSessionBtn.style.display = 'block';
          } else {
            console.warn('Cannot show end session button - missing booking_id:', data);
            if (endSessionBtn) endSessionBtn.style.display = 'none';
          }
        } else {
          // Show waiting message
          document.getElementById('session-time-info').style.display = 'none';
          document.getElementById('session-waiting').style.display = 'block';
          var endSessionBtn = document.getElementById('end-session-btn');
          if (endSessionBtn) {
            endSessionBtn.style.display = 'none';
            endSessionBtn.removeAttribute('data-booking-id'); // Clear booking_id when hiding
          }
        }
        
        // Show modal only if called from button click, not on page load
        // The modal will be shown by the button click handler
      }
    })
    .catch(error => {
      console.error('Error checking session:', error);
      // On error, still try to show button if elements exist (might be a network issue)
      // But don't force show if we can't verify booking status
      console.warn('Failed to check active session, will retry on next interval');
    });
}

// Function to show my session modal (called from button click)
// Add retry counter to prevent infinite loops
var showMySessionModalRetryCount = 0;
var MAX_RETRY_COUNT = 5;

function showMySessionModal() {
  console.log('showMySessionModal called, retry count:', showMySessionModalRetryCount);
  
  // Check if modal elements exist
  var modalElement = document.getElementById('mySessionModal');
  if (!modalElement) {
    console.error('mySessionModal element not found');
    if (showMySessionModalRetryCount < MAX_RETRY_COUNT) {
      showMySessionModalRetryCount++;
      setTimeout(function() {
        showMySessionModal();
      }, 200);
      return;
    } else {
      alert('Error: Session modal not found. Please refresh the page.');
      showMySessionModalRetryCount = 0; // Reset counter
      return;
    }
  }
  
  // Reset retry counter if modal found
  showMySessionModalRetryCount = 0;
  
  fetch('/ajax/get-my-active-booking/')
    .then(response => {
      if (!response.ok) {
        throw new Error('Network response was not ok: ' + response.status);
      }
      return response.json();
    })
    .then(data => {
      console.log('Session modal data:', data);
      
      if (data.has_booking) {
        // Get all modal elements
        var pcNameEl = document.getElementById('session-pc-name');
        var statusEl = document.getElementById('session-status');
        var timeInfoEl = document.getElementById('session-time-info');
        var waitingEl = document.getElementById('session-waiting');
        var timeLeftEl = document.getElementById('session-time-left');
        var endSessionBtn = document.getElementById('end-session-btn');
        
        // Check if critical elements exist - retry if not found
        if (!pcNameEl || !statusEl) {
          console.warn('Critical modal elements not found, retrying in 200ms...');
          console.log('Missing elements:', {
            pcNameEl: !pcNameEl,
            statusEl: !statusEl,
            timeInfoEl: !timeInfoEl,
            waitingEl: !waitingEl,
            timeLeftEl: !timeLeftEl
          });
          
          // Retry with limit
          if (showMySessionModalRetryCount < MAX_RETRY_COUNT) {
            showMySessionModalRetryCount++;
            setTimeout(function() {
              showMySessionModal();
            }, 200);
            return;
          } else {
            console.error('Max retry count reached, showing error');
            alert('Error: Session modal elements not found. Please refresh the page.');
            showMySessionModalRetryCount = 0; // Reset counter
            return;
          }
        }
        
        // Reset retry counter if critical elements found
        showMySessionModalRetryCount = 0;
        
        // Update modal content - handle missing optional elements gracefully
        if (pcNameEl) {
          pcNameEl.textContent = data.pc_name || 'Unknown PC';
        }
        if (statusEl) {
          statusEl.textContent = (data.status === 'in_use' || data.booking_status === 'confirmed') ? 'Active' : 'Waiting Approval';
          statusEl.className = (data.status === 'in_use' || data.booking_status === 'confirmed') ? 'badge bg-success' : 'badge bg-warning';
        }
        
        // ALWAYS show end session button if booking_id exists
        if (data.booking_id) {
          window.currentBookingId = data.booking_id;
          console.log('Setting up end session buttons with booking_id:', data.booking_id);
          
          // Configure ALL end session buttons
          var endSessionTopBtn = document.getElementById('end-session-top-btn');
          var endSessionPendingBtn = document.getElementById('end-session-pending-btn');
          
          // Function to configure a button
          function configureEndSessionButton(btn, btnName) {
            if (btn) {
              btn.setAttribute('data-booking-id', data.booking_id);
              btn.setAttribute('onclick', 'window.endMySession(this); return false;');
              btn.onclick = function(e) {
                e.preventDefault();
                e.stopPropagation();
                return window.endMySession(this);
              };
              // Force show the button
              btn.style.display = 'block';
              btn.style.visibility = 'visible';
              btn.style.opacity = '1';
              btn.removeAttribute('hidden');
              btn.removeAttribute('style'); // Remove inline style that might hide it
              btn.style.display = 'block';
              btn.style.visibility = 'visible';
              btn.style.opacity = '1';
              
              // Also ensure parent container is visible
              var parent = btn.parentElement;
              if (parent) {
                parent.style.display = 'block';
                parent.style.visibility = 'visible';
              }
              
              console.log(btnName + ' button configured and shown, booking_id:', data.booking_id);
              console.log('Button computed style:', window.getComputedStyle(btn).display);
              return true;
            } else {
              console.warn(btnName + ' button element not found');
              return false;
            }
          }
          
          // Configure top button
          configureEndSessionButton(endSessionTopBtn, 'Top end session');
          
          // Configure pending button
          configureEndSessionButton(endSessionPendingBtn, 'Pending booking cancel');
          
          // Configure footer button
          configureEndSessionButton(endSessionBtn, 'Footer end session');
          
          // Double-check after a short delay
          setTimeout(function() {
            console.log('Double-checking button visibility...');
            if (endSessionTopBtn) {
              console.log('Top button display:', endSessionTopBtn.style.display, 'computed:', window.getComputedStyle(endSessionTopBtn).display);
              if (window.getComputedStyle(endSessionTopBtn).display === 'none') {
                endSessionTopBtn.style.display = 'block';
                endSessionTopBtn.style.setProperty('display', 'block', 'important');
              }
            }
            if (endSessionBtn) {
              console.log('Footer button display:', endSessionBtn.style.display, 'computed:', window.getComputedStyle(endSessionBtn).display);
              if (window.getComputedStyle(endSessionBtn).display === 'none') {
                endSessionBtn.style.display = 'block';
                endSessionBtn.style.setProperty('display', 'block', 'important');
              }
            }
          }, 100);
        } else {
          console.warn('No booking_id in response:', data);
        }
        
        if ((data.status === 'in_use' || data.booking_status === 'confirmed') && data.time_remaining) {
          // Show time info
          if (timeInfoEl) {
            timeInfoEl.style.display = 'block';
          }
          if (waitingEl) {
            waitingEl.style.display = 'none';
          }
          if (timeLeftEl) {
            timeLeftEl.textContent = data.time_remaining;
          }
          
          // Show end time if available
          var endTimeEl = document.getElementById('session-end-time');
          if (endTimeEl && data.end_time) {
            var endTime = new Date(data.end_time);
            endTimeEl.textContent = 'Session ends at: ' + endTime.toLocaleTimeString();
          }
          
          // Start live countdown timer in modal
          if (data.end_time) {
            startModalCountdown(data.end_time, timeLeftEl);
          }
        } else {
          // Show waiting message (booking in queue)
          if (timeInfoEl) {
            timeInfoEl.style.display = 'none';
          }
          if (waitingEl) {
            waitingEl.style.display = 'block';
          }
        }
        
        // Show modal
        if (typeof bootstrap !== 'undefined') {
          var modal = new bootstrap.Modal(modalElement);
          modal.show();
          console.log('Session modal shown');
        } else {
          console.error('Bootstrap not available');
          alert('Error: Bootstrap modal library not loaded. Please refresh the page.');
        }
      } else {
        alert('You do not have an active session.');
        console.log('No active booking found');
      }
    })
    .catch(error => {
      console.error('Error checking session:', error);
      alert('Error loading session information: ' + error.message);
    });
};

// Global variable for modal countdown
var modalCountdownInterval = null;

// Start live countdown timer in modal
function startModalCountdown(endTimeStr, timeLeftEl) {
  // Clear any existing countdown
  if (modalCountdownInterval) {
    clearInterval(modalCountdownInterval);
  }
  
  var endTime = new Date(endTimeStr);
  
  // Update immediately
  updateModalCountdown(endTime, timeLeftEl);
  
  // Update every second
  modalCountdownInterval = setInterval(function() {
    updateModalCountdown(endTime, timeLeftEl);
  }, 1000);
}

// Update modal countdown display
function updateModalCountdown(endTime, timeLeftEl) {
  if (!timeLeftEl) return;
  
  var now = new Date();
  var diff = endTime - now;
  
  if (diff > 0) {
    var hours = Math.floor(diff / (1000 * 60 * 60));
    var minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
    var seconds = Math.floor((diff % (1000 * 60)) / 1000);
    
    var timeStr = '';
    if (hours > 0) {
      timeStr = hours + 'h ' + minutes + 'm ' + seconds + 's';
    } else if (minutes > 0) {
      timeStr = minutes + 'm ' + seconds + 's';
    } else {
      timeStr = seconds + 's';
    }
    
    timeLeftEl.textContent = timeStr;
    
    // Change color if less than 5 minutes
    if (diff < 5 * 60 * 1000) {
      timeLeftEl.className = 'text-danger';
    } else {
      timeLeftEl.className = 'text-primary';
    }
  } else {
    timeLeftEl.textContent = 'Expired';
    timeLeftEl.className = 'text-danger';
    if (modalCountdownInterval) {
      clearInterval(modalCountdownInterval);
      modalCountdownInterval = null;
    }
  }
}

// Simple function to end session directly from button
window.endMySession = function(button) {
  var bookingId = button.getAttribute('data-booking-id') || window.currentBookingId;
  
  console.log('endMySession called, booking_id:', bookingId);
  
  if (!bookingId || bookingId === '' || bookingId === 'null') {
    alert('Error: Booking ID not found. Please refresh the page.');
    return false;
  }
  
  if (confirm('Are you sure you want to end your session early?')) {
    var url = '/ajax/end-session/' + bookingId + '/';
    console.log('Calling end session URL:', url);
    
    // Get CSRF token
    var csrftoken = document.querySelector('[name=csrfmiddlewaretoken]')?.value || 
                    document.cookie.match(/csrftoken=([^;]+)/)?.[1] || '';
    
    fetch(url, {
      method: 'POST',
      headers: {
        'X-CSRFToken': csrftoken,
        'Content-Type': 'application/json'
      }
    })
    .then(response => {
      console.log('Response status:', response.status);
      if (!response.ok) {
        return response.text().then(text => {
          console.error('Error response:', text);
          throw new Error('HTTP error! status: ' + response.status);
        });
      }
      return response.json();
    })
    .then(data => {
      console.log('End session response:', data);
      if (data.success) {
        alert(data.message || 'Session ended successfully');
        // Close the modal
        var modal = bootstrap.Modal.getInstance(document.getElementById('mySessionModal'));
        if (modal) {
          modal.hide();
        }
        // Reload page
        location.reload();
      } else {
        alert('Error: ' + (data.error || data.message || 'Failed to end session'));
      }
    })
    .catch(error => {
      console.error('Error ending session:', error);
      alert('Error: Failed to end session. ' + error.message + '\nPlease try again.');
    });
  }
  
  return false;
};

// Clear modal countdown when modal is closed
document.addEventListener('DOMContentLoaded', function() {
  var mySessionModal = document.getElementById('mySessionModal');
  if (mySessionModal) {
    mySessionModal.addEventListener('hidden.bs.modal', function() {
      if (modalCountdownInterval) {
        clearInterval(modalCountdownInterval);
        modalCountdownInterval = null;
      }
    });
  }
});

// Add session check button and polling
document.addEventListener('DOMContentLoaded', function() {
  // Note: checkMyActiveSession is now called periodically in the main DOMContentLoaded handler

  // Lightweight polling for faculty bulk booking decision for this user
  // Shows a one-time notification using localStorage to avoid repeats
  function pollFacultyBookingNotice() {
    fetch('/ajax/check-faculty-booking-status/', { cache: 'no-store' })
      .then(function(r){ return r.ok ? r.json() : { has_update:false }; })
      .then(function(data){
        if (!data || !data.has_update) return;
        var key = 'seenFacultyBooking_' + (data.booking_id || '');
        var already = localStorage.getItem(key);
        if (already) return;
        // Only notify when status is confirmed or cancelled
        if (data.status === 'confirmed' || data.status === 'cancelled') {
          // Build a centered Bootstrap modal instead of alert()
          function ensureModal() {
            var el = document.getElementById('centerNoticeModal');
            if (el) return el;
            el = document.createElement('div');
            el.id = 'centerNoticeModal';
            el.className = 'modal fade';
            el.innerHTML = '\n<div class="modal-dialog modal-dialog-centered">\n  <div class="modal-content">\n    <div class="modal-header">\n      <h5 class="modal-title"></h5>\n      <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>\n    </div>\n    <div class="modal-body"></div>\n    <div class="modal-footer">\n      <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>\n    </div>\n  </div>\n</div>';
            document.body.appendChild(el);
            return el;
          }
          function setModal(title, html, status) {
            var el = ensureModal();
            var titleEl = el.querySelector('.modal-title');
            var bodyEl = el.querySelector('.modal-body');
            titleEl.textContent = title;
            bodyEl.innerHTML = html;
            // Header color by status
            var header = el.querySelector('.modal-header');
            header.classList.remove('bg-success','bg-danger','text-white');
            if (status === 'confirmed') { header.classList.add('bg-success','text-white'); }
            if (status === 'cancelled') { header.classList.add('bg-danger','text-white'); }
            var modal = bootstrap && bootstrap.Modal ? new bootstrap.Modal(el) : null;
            if (modal) modal.show(); else alert(title + '\n' + bodyEl.textContent);
          }
          var heading = 'Faculty bulk booking ' + (data.status === 'confirmed' ? 'APPROVED' : 'DECLINED');
          var body = '<div class="mb-2"><strong>Faculty:</strong> ' + (data.faculty_name || 'N/A') + '</div>' +
                     (data.start ? '<div class="mb-1"><strong>Start:</strong> ' + new Date(data.start).toLocaleString() + '</div>' : '') +
                     (data.end ? '<div class="mb-1"><strong>End:</strong> ' + new Date(data.end).toLocaleString() + '</div>' : '');
          setModal(heading, body, data.status);
          localStorage.setItem(key, '1');
        }
      })
      .catch(function(){ /* ignore */ });
  }
  // Run immediately and then every 30s
  pollFacultyBookingNotice();
  setInterval(pollFacultyBookingNotice, 30000);
  
  // Handle end session button - use direct onclick handler
  // Store booking_id in a variable accessible to the handler
  window.currentBookingId = null;
  
  // Function to handle end session early from timeRemainingModal
  window.handleEndSessionEarly = function(e) {
    if (e) {
      e.preventDefault();
      e.stopPropagation();
    }
    
    var btn = document.getElementById('end-session-early-btn');
    var bookingId = btn ? btn.getAttribute('data-booking-id') : null;
    
    // Also try to get booking ID from hidden field or other sources
    if (!bookingId || bookingId === '' || bookingId === 'null' || bookingId === 'undefined') {
      var bookingIdEl = document.getElementById('booking_id');
      if (bookingIdEl) {
        bookingId = bookingIdEl.textContent || bookingIdEl.value;
      }
    }
    
    if (!bookingId || bookingId === '' || bookingId === 'null' || bookingId === 'undefined') {
      alert('Error: Booking ID not found. Please refresh the page and try again.');
      return false;
    }
    
    bookingId = String(bookingId).trim();
    
    if (!bookingId || isNaN(parseInt(bookingId))) {
      alert('Error: Invalid booking ID format. Please refresh the page and try again.');
      return false;
    }
    
    if (confirm('Are you sure you want to end your session early?')) {
      var url = '/ajax/end-session/' + bookingId + '/';
      console.log('Ending session with booking ID:', bookingId);
      console.log('URL:', url);
      
      fetch(url, {
        method: 'POST',
        headers: {
          'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]')?.value || 
                        document.cookie.match(/csrftoken=([^;]+)/)?.[1] || '',
          'Content-Type': 'application/json'
        }
      })
      .then(response => {
        console.log('Response status:', response.status);
        if (!response.ok) {
          return response.text().then(text => {
            console.error('Error response:', text);
            throw new Error('HTTP error! status: ' + response.status);
          });
        }
        return response.json();
      })
      .then(data => {
        console.log('End session response:', data);
        if (data.success) {
          alert(data.message || 'Session ended successfully');
          // Close the modal
          var modal = bootstrap.Modal.getInstance(document.getElementById('timeRemainingModal'));
          if (modal) modal.hide();
          location.reload();
        } else {
          alert('Error: ' + (data.error || data.message || 'Failed to end session'));
        }
      })
      .catch(error => {
        console.error('Error ending session:', error);
        alert('Error: Failed to end session. ' + error.message + '\nPlease try again.');
      });
    }
    return false;
  };

  // Function to handle end session click
  // Note: handleEndSession is now defined in the extra_head block section above
  // so it's available before the HTML that uses it
  
  // Set onclick directly on button (will be set when button is shown)
  // Note: The onclick is also set in showMySessionModal when the modal is opened
  var endSessionBtn = document.getElementById('end-session-btn');
  if (endSessionBtn) {
    endSessionBtn.onclick = function(e) {
      if (e) {
        e.preventDefault();
        e.stopPropagation();
      }
      return window.handleEndSession(e);
    };
  }
  
  // Handle "My Session" button click (header button)
  var showMySessionBtn = document.getElementById('showMySessionBtn');
  if (showMySessionBtn) {
    showMySessionBtn.addEventListener('click', function() {
      // Show modal with session information
      showMySessionModal();
    });
  }
  
  // Handle "My Session" button click (main button - replaces View QR Code)
  var showMySessionBtnMain = document.getElementById('showMySessionBtnMain');
  if (showMySessionBtnMain) {
    showMySessionBtnMain.addEventListener('click', function() {
      // Show modal with session information
      showMySessionModal();
    });
  }
  
  // Check for active session on page load - with a small delay to ensure DOM is ready
  // Call immediately and also after delays
  checkMyActiveSession();
  setTimeout(function() {
    checkMyActiveSession();
  }, 500);
  setTimeout(function() {
    checkMyActiveSession();
  }, 2000);
  
  // Also check periodically to ensure button visibility is correct
  setInterval(function() {
    checkMyActiveSession();
  }, 5000); // Check every 5 seconds
  
  // Auto-refresh PC status every 2 seconds to show real-time updates
  function refreshPCStatusForReservation() {
    fetch('/ajax/get-all-pc-status/')
      .then(response => {
        if (!response.ok) {
          console.error('âŒ Polling: Failed to fetch PC status. Status:', response.status);
          return;
        }
        return response.json();
      })
      .then(data => {
        if (!data || !data.pcs) {
          console.warn('âš ï¸ Polling: No PC data received');
          return;
        }
        
        // Debug: Log all in_queue PCs
        var inQueuePCs = data.pcs.filter(function(pc) { return pc.booking_status === 'in_queue'; });
        if (inQueuePCs.length > 0) {
          console.log('ðŸŸ¡ Polling: Found', inQueuePCs.length, 'PC(s) in_queue:', inQueuePCs.map(function(pc) { return pc.name; }));
        }
          
          data.pcs.forEach(function(pcData) {
            // Find the PC button by data-pc-id
            var pcButton = document.querySelector('.pc-button-modern[data-pc-id="' + pcData.id + '"]');
            if (pcButton) {
              var oldBookingStatus = pcButton.getAttribute('data-booking-status');
              var newBookingStatus = pcData.booking_status || 'available';
              
              // Debug logging for queue status
              if (newBookingStatus === 'in_queue') {
                console.log('ðŸ”µ Polling: Server returned in_queue for PC:', pcData.name, 'PC ID:', pcData.id, 'Old status:', oldBookingStatus);
              }
              
              // Always update data attributes to ensure they're current
              pcButton.setAttribute('data-booking-status', newBookingStatus);
              pcButton.setAttribute('data-pc-status', pcData.status || 'connected');
              pcButton.setAttribute('data-pc-condition', pcData.system_condition || 'active');
              
              // Always update button classes and styling to ensure consistency
              // Don't just update when status changes - always update to keep in sync
              var statusChanged = oldBookingStatus !== newBookingStatus;
              if (statusChanged) {
                console.log('PC status changed:', pcData.name, 'from', oldBookingStatus, 'to', newBookingStatus);
              }
              
              // IMPORTANT: Always trust the server status for all users
              // The server should correctly return 'in_queue' if there's a pending booking
              // Don't override the server status - it should be correct for all users
              
              // Always update button classes and styling
              // IMPORTANT: Remove ALL status classes first, especially pc-available
              pcButton.classList.remove('pc-available', 'pc-queue', 'pc-used', 'pc-repair', 'pc-offline', 'selected', 'pc-selected', 'text-success');
              
              // Also remove any inline styles that might conflict (but keep our important ones)
              // Only remove if not in_queue (we'll set them for in_queue)
              if (newBookingStatus !== 'in_queue') {
                pcButton.style.removeProperty('background-color');
                pcButton.style.removeProperty('border-color');
              }
              
              // Remove selection if PC is no longer available
              if (newBookingStatus !== 'available') {
                var pcIdInput = document.getElementById('pc_id');
                if (pcIdInput && pcIdInput.value == pcData.id) {
                  pcIdInput.value = '';
                }
              }
              
              if (pcData.system_condition === 'repair') {
                pcButton.classList.add('pc-repair');
                pcButton.disabled = true;
                pcButton.style.cursor = 'not-allowed';
                pcButton.style.opacity = '0.6';
                pcButton.style.pointerEvents = 'none';
                pcButton.onclick = function(e) {
                  e.preventDefault();
                  e.stopPropagation();
                  showPCStatus(pcData.id, pcButton);
                  return false;
                };
              } else if (pcData.status === 'disconnected') {
                pcButton.classList.add('pc-offline');
                pcButton.disabled = true;
                pcButton.style.cursor = 'not-allowed';
                pcButton.style.opacity = '0.6';
                pcButton.style.pointerEvents = 'none';
                pcButton.onclick = function(e) {
                  e.preventDefault();
                  e.stopPropagation();
                  showPCStatus(pcData.id, pcButton);
                  return false;
                };
              } else if (newBookingStatus === 'in_use') {
                pcButton.classList.add('pc-used');
                pcButton.disabled = false;
                pcButton.style.cursor = 'pointer';
                pcButton.style.opacity = '1';
                pcButton.style.pointerEvents = 'auto';
                pcButton.onclick = function() {
                  showPCStatus(pcData.id, pcButton);
                  return false;
                };
              } else if (newBookingStatus === 'in_queue') {
                // PC is in queue - show yellow color for ALL users
                console.log('ðŸŸ¡ Polling: Setting PC', pcData.name, '(ID:', pcData.id, ') to in_queue (yellow) for ALL users');
                
                // CRITICAL: Remove ALL status classes first - be very aggressive
                pcButton.classList.remove('pc-available', 'pc-used', 'pc-selected', 'selected', 'text-success', 'bg-success', 'bg-warning', 'bg-danger', 'pc-repair', 'pc-offline');
                
                // Add queue class
                pcButton.classList.add('pc-queue');
                
                // Force yellow color with inline styles - use multiple methods to ensure it sticks
                // Method 1: setProperty with important
                pcButton.style.setProperty('background-color', '#FFF9C4', 'important');
                pcButton.style.setProperty('border-color', '#FFC107', 'important');
                pcButton.style.setProperty('border-width', '2px', 'important');
                pcButton.style.setProperty('border-style', 'solid', 'important');
                
                // Method 2: Also set directly as fallback
                pcButton.style.backgroundColor = '#FFF9C4';
                pcButton.style.borderColor = '#FFC107';
                pcButton.style.borderWidth = '2px';
                pcButton.style.borderStyle = 'solid';
                
                // Remove any conflicting inline styles
                pcButton.style.removeProperty('color');
                
                // Verify the change was applied
                var appliedStatus = pcButton.getAttribute('data-booking-status');
                var hasQueueClass = pcButton.classList.contains('pc-queue');
                console.log('   âœ… Applied in_queue status. data-booking-status:', appliedStatus, 'has pc-queue class:', hasQueueClass);
                
                // Also update icon and text colors - be very explicit
                var iconEl = pcButton.querySelector('.pc-icon-modern');
                var numberEl = pcButton.querySelector('.pc-number');
                if (iconEl) {
                  iconEl.style.setProperty('color', '#F57C00', 'important');
                  iconEl.style.color = '#F57C00';
                  console.log('ðŸŸ¡ Icon color set to orange for PC:', pcData.name);
                }
                if (numberEl) {
                  numberEl.style.setProperty('color', '#F57C00', 'important');
                  numberEl.style.color = '#F57C00';
                  console.log('ðŸŸ¡ Number color set to orange for PC:', pcData.name);
                }
                
                // Also check for any nested elements
                var allChildren = pcButton.querySelectorAll('*');
                allChildren.forEach(function(child) {
                  if (child.classList.contains('pc-icon-modern') || child.classList.contains('pc-number')) {
                    child.style.setProperty('color', '#F57C00', 'important');
                    child.style.color = '#F57C00';
                  }
                });
                
                pcButton.disabled = false;
                pcButton.style.cursor = 'pointer';
                pcButton.style.opacity = '1';
                pcButton.style.pointerEvents = 'auto';
                pcButton.onclick = function() {
                  showPCStatus(pcData.id, pcButton);
                  return false;
                };
                
                // Verify the color was applied
                setTimeout(function() {
                  var computedBg = window.getComputedStyle(pcButton).backgroundColor;
                  var computedBorder = window.getComputedStyle(pcButton).borderColor;
                  console.log('ðŸ” Verification for PC', pcData.name, '- Background:', computedBg, 'Border:', computedBorder);
                  if (computedBg !== 'rgb(255, 249, 196)' && !computedBg.includes('255, 249, 196')) {
                    console.error('âŒ Background color NOT applied! Expected #FFF9C4, got:', computedBg);
                    // Force it again
                    pcButton.style.setProperty('background-color', '#FFF9C4', 'important');
                    pcButton.style.backgroundColor = '#FFF9C4';
                  } else {
                    console.log('âœ… Background color verified for PC', pcData.name);
                  }
                }, 50);
                
                console.log('âœ… PC', pcData.name, 'successfully set to yellow (in_queue)');
              } else {
                // Only set to available if status is actually 'available'
                // Make sure we're not overriding in_queue status
                if (newBookingStatus === 'available') {
                  pcButton.classList.add('pc-available');
                  // Remove any inline styles that might conflict
                  pcButton.style.removeProperty('background-color');
                  pcButton.style.removeProperty('border-color');
                  // Check if user has active booking (student or faculty) - if so, disable selection
                  if (window.__hasActiveBooking || window.__hasActiveFacultyBooking) {
                    pcButton.disabled = true;
                    pcButton.style.cursor = 'not-allowed';
                    pcButton.style.opacity = '0.6';
                    pcButton.style.pointerEvents = 'none';
                    // Set onclick to show alert for faculty bookings
                    if (window.__hasActiveFacultyBooking) {
                      pcButton.onclick = function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        alert('You have an active faculty booking. Please wait for your current booking to be processed or cancelled before booking another PC.');
                        return false;
                      };
                    } else {
                      pcButton.onclick = function() {
                        return false;
                      };
                    }
                  } else {
                    pcButton.disabled = false;
                    pcButton.style.cursor = 'pointer';
                    pcButton.style.opacity = '1';
                    pcButton.style.pointerEvents = 'auto';
                    var pcId = pcData.id;
                    pcButton.onclick = function() {
                      selectPCForReservation(pcId, pcButton);
                    };
                  }
                } else {
                  // Status is not available and not in_queue or in_use - log for debugging
                  console.warn('Unexpected booking status for PC', pcData.name, ':', newBookingStatus);
                }
              }
            }
          });
          
          // Update available count
          var availableCount = data.pcs.filter(function(pc) {
            return pc.booking_status === 'available' && 
                   pc.system_condition !== 'repair' && 
                   pc.status === 'connected';
          }).length;
          
          var countElement = document.getElementById('available-count');
          if (countElement) {
            countElement.textContent = availableCount;
          }
          
          // After updating PC buttons, re-check and disable if user has active booking
          // This ensures buttons stay disabled even after refresh
          if (typeof window.checkAndDisablePCSelection === 'function') {
            window.checkAndDisablePCSelection();
          } else if (typeof checkAndDisablePCSelection === 'function') {
            checkAndDisablePCSelection();
          }
          
          // Also check and disable if faculty has active booking
          // This ensures faculty PC buttons stay disabled even after refresh
          if (typeof window.checkAndDisableFacultyPCSelection === 'function') {
            window.checkAndDisableFacultyPCSelection();
          } else if (typeof checkAndDisableFacultyPCSelection === 'function') {
            checkAndDisableFacultyPCSelection();
          }
        }
      })
      .catch(error => {
        console.error('Error refreshing PC status:', error);
      });
  }
  
  // Make it globally accessible
  window.refreshPCStatusForReservation = refreshPCStatusForReservation;
  
  // Global variable to store approval checker interval (vanilla JS version)
  var qrApprovalCheckerIntervalVanilla = null;
  
  // Function to start checking for QR code approval (when scanned) - vanilla JS version
  function startQRApprovalCheckerVanilla(bookingId) {
    // Clear any existing checker
    if (qrApprovalCheckerIntervalVanilla) {
      clearInterval(qrApprovalCheckerIntervalVanilla);
      qrApprovalCheckerIntervalVanilla = null;
    }
    
    if (!bookingId) return;
    
    // Check every 2 seconds if QR code has been scanned (booking confirmed)
    qrApprovalCheckerIntervalVanilla = setInterval(function() {
      // Only check if View QR button is still visible
      var viewQRContainer = document.getElementById('viewQRButtonContainer');
      var viewQRCodeBtnNext = document.getElementById('viewQRCodeButtonNext');
      var isVisible = (viewQRContainer && viewQRContainer.style.display !== 'none' && viewQRContainer.style.visibility !== 'hidden') ||
                      (viewQRCodeBtnNext && viewQRCodeBtnNext.style.display !== 'none');
      
      if (!isVisible) {
        clearInterval(qrApprovalCheckerIntervalVanilla);
        qrApprovalCheckerIntervalVanilla = null;
        return;
      }
      
      // Check booking status
      fetch('/ajax/waiting-approval/' + bookingId + '/')
        .then(response => response.json())
        .then(function(data) {
          if (data.status === 'confirmed') {
            console.log('QR code scanned! Booking confirmed. Refreshing page...');
            
            // Clear the checker
            clearInterval(qrApprovalCheckerIntervalVanilla);
            qrApprovalCheckerIntervalVanilla = null;
            
            // Clear QR code data
            try {
              localStorage.removeItem('qrCodeData');
              localStorage.removeItem('qrBookingId');
              localStorage.removeItem('qrPCId');
              localStorage.removeItem('qrCodeTimestamp');
            } catch (e) {
              console.error('Error clearing localStorage:', e);
            }
            
            // Refresh the page to show updated status
            setTimeout(function() {
              window.location.reload();
            }, 500);
          } else if (data.status === 'cancelled') {
            console.log('Booking cancelled. Refreshing page...');
            
            // Clear the checker
            clearInterval(qrApprovalCheckerIntervalVanilla);
            qrApprovalCheckerIntervalVanilla = null;
            
            // Clear QR code data
            try {
              localStorage.removeItem('qrCodeData');
              localStorage.removeItem('qrBookingId');
              localStorage.removeItem('qrPCId');
              localStorage.removeItem('qrCodeTimestamp');
            } catch (e) {
              console.error('Error clearing localStorage:', e);
            }
            
            // Refresh the page
            setTimeout(function() {
              window.location.reload();
            }, 500);
          }
        })
        .catch(function(error) {
          console.error('Error checking approval status:', error);
        });
    }, 2000); // Check every 2 seconds
  }
  
  // Make it globally accessible
  window.startQRApprovalCheckerVanilla = startQRApprovalCheckerVanilla;
  
  // WebSocket connection for real-time PC status updates
  var pcStatusWebSocket = null;
  var pcStatusReconnectInterval = null;
  
  function connectPCStatusWebSocket() {
    // Get WebSocket URL - use wss:// for HTTPS, ws:// for HTTP
    var protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    var wsUrl = protocol + '//' + window.location.host + '/ws/pc-status-updates/';
    
    try {
      pcStatusWebSocket = new WebSocket(wsUrl);
      
      pcStatusWebSocket.onopen = function() {
        console.log('âœ… PC Status WebSocket connected for user');
        console.log('   WebSocket URL:', wsUrl);
        console.log('   Ready to receive real-time PC status updates');
        // Clear reconnect interval if connection is successful
        if (pcStatusReconnectInterval) {
          clearInterval(pcStatusReconnectInterval);
          pcStatusReconnectInterval = null;
        }
        // Send heartbeat
        if (pcStatusWebSocket.readyState === WebSocket.OPEN) {
          pcStatusWebSocket.send(JSON.stringify({type: 'heartbeat'}));
        }
      };
      
      pcStatusWebSocket.onmessage = function(event) {
        try {
          var data = JSON.parse(event.data);
          
          if (data.type === 'pc_status_update') {
            console.log('ðŸ“¥ Received PC status update:', data);
            console.log('   PC ID:', data.pc_id, 'PC Name:', data.pc_name, 'Booking Status:', data.booking_status);
            
            // Find the PC button by data-pc-id
            var pcButton = document.querySelector('.pc-button-modern[data-pc-id="' + data.pc_id + '"]');
            if (pcButton) {
              console.log('   âœ… Found PC button for', data.pc_name);
              // Update data attributes
              pcButton.setAttribute('data-booking-status', data.booking_status || 'available');
              pcButton.setAttribute('data-pc-status', data.status || 'connected');
              pcButton.setAttribute('data-pc-condition', data.system_condition || 'active');
              
              // Update button classes
              pcButton.classList.remove('pc-available', 'pc-queue', 'pc-used', 'pc-repair', 'pc-offline', 'selected', 'pc-selected', 'text-success');
              
              // Apply appropriate classes based on status
              if (data.system_condition === 'repair') {
                pcButton.classList.add('pc-repair');
              } else if (data.status === 'disconnected') {
                pcButton.classList.add('pc-offline');
              } else if (data.booking_status === 'in_use') {
                pcButton.classList.add('pc-used');
              } else if (data.booking_status === 'in_queue') {
                // PC is in queue - show yellow color for ALL users
                console.log('ðŸŸ¡ WebSocket: Setting PC', data.pc_name, '(ID:', data.pc_id, ') to in_queue (yellow)');
                
                // CRITICAL: Remove ALL status classes first - be very aggressive
                pcButton.classList.remove('pc-available', 'pc-used', 'pc-selected', 'selected', 'text-success', 'bg-success', 'bg-warning', 'bg-danger');
                
                // Add queue class
                pcButton.classList.add('pc-queue');
                
                // Force yellow color with inline styles - use multiple methods to ensure it sticks
                // Method 1: setProperty with important
                pcButton.style.setProperty('background-color', '#FFF9C4', 'important');
                pcButton.style.setProperty('border-color', '#FFC107', 'important');
                pcButton.style.setProperty('border-width', '2px', 'important');
                pcButton.style.setProperty('border-style', 'solid', 'important');
                
                // Method 2: Also set directly as fallback
                pcButton.style.backgroundColor = '#FFF9C4';
                pcButton.style.borderColor = '#FFC107';
                pcButton.style.borderWidth = '2px';
                pcButton.style.borderStyle = 'solid';
                
                // Remove any conflicting inline styles
                pcButton.style.removeProperty('color');
              } else {
                pcButton.classList.add('pc-available');
                // Remove inline styles for available status
                pcButton.style.removeProperty('background-color');
                pcButton.style.removeProperty('border-color');
              }
              
              // Show notification if message is provided
              if (data.message) {
                console.log('ðŸ“¢ PC Status Update:', data.message);
                // Show a subtle notification
                if (data.booking_status === 'available' && data.available_pcs_count > 0) {
                  // Show success notification for available PCs
                  if (typeof showSuccessNotification === 'function') {
                    showSuccessNotification(data.message + ' (' + data.available_pcs_count + ' PC(s) available)');
                  }
                }
              }
            } else {
              console.warn('PC button not found for PC ID:', data.pc_id);
            }
          } else if (data.type === 'heartbeat_ack') {
            // Heartbeat acknowledged, connection is alive
            console.log('ðŸ’“ WebSocket heartbeat acknowledged');
          }
        } catch (e) {
          console.error('Error parsing WebSocket message:', e);
        }
      };
      
      pcStatusWebSocket.onerror = function(error) {
        console.error('âŒ PC Status WebSocket error:', error);
      };
      
      pcStatusWebSocket.onclose = function() {
        console.log('âŒ PC Status WebSocket closed, attempting to reconnect...');
        // Attempt to reconnect after 3 seconds
        if (!pcStatusReconnectInterval) {
          pcStatusReconnectInterval = setInterval(function() {
            if (!pcStatusWebSocket || pcStatusWebSocket.readyState === WebSocket.CLOSED) {
              console.log('ðŸ”„ Attempting to reconnect PC Status WebSocket...');
              connectPCStatusWebSocket();
            }
          }, 3000);
        }
      };
    } catch (e) {
      console.error('Error creating PC Status WebSocket:', e);
    }
  }
  
  // Connect WebSocket when page loads
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', connectPCStatusWebSocket);
  } else {
    connectPCStatusWebSocket();
  }
  
  // Refresh PC status every 2 seconds as fallback (WebSocket is primary, but polling ensures updates)
  // Use 2 seconds instead of 5 to catch in_queue status faster for all users
  setInterval(refreshPCStatusForReservation, 2000);
  
  // Also refresh immediately on page load - multiple times to catch any missed updates
  // This is critical for other users who load the page after a booking is created
  console.log('ðŸ”„ Starting immediate PC status refresh (will run multiple times on page load)');
  refreshPCStatusForReservation();
  setTimeout(refreshPCStatusForReservation, 100);
  setTimeout(refreshPCStatusForReservation, 500);
  setTimeout(refreshPCStatusForReservation, 1000);
  setTimeout(refreshPCStatusForReservation, 2000);
  
  console.log('âœ… PC status refresh started - WebSocket for real-time updates, polling every 2 seconds as fallback');
  
  // Also check when page becomes visible (user switches tabs back)
  document.addEventListener('visibilitychange', function() {
    if (!document.hidden) {
      console.log('Page became visible, checking active session');
      checkMyActiveSession();
      // Also refresh PC status when page becomes visible
      refreshPCStatusForReservation();
    }
  });
  
  // Mobile menu toggle in reservation body
  function initMobileMenuToggleReservation() {
    var mobileMenuToggleReservation = document.getElementById('mobile-menu-toggle-reservation');
    var mobileMenuToggle = document.getElementById('mobile-menu-toggle');
    var mobileNav = document.getElementById('mobile-nav');
    var mobileNavOverlay = document.getElementById('mobile-nav-overlay');
    var sidebar = document.getElementById('sidebar');
    var sidebarOverlay = document.getElementById('sidebar-overlay');
    
    console.log('Initializing mobile menu toggle reservation', {
      button: mobileMenuToggleReservation,
      mobileNav: mobileNav,
      sidebar: sidebar
    });
    
    if (mobileMenuToggleReservation) {
      // Hide the original mobile menu toggle in header
      if (mobileMenuToggle) {
        mobileMenuToggle.style.display = 'none';
      }
      
      // Remove any existing event listeners by cloning the element
      var newButton = mobileMenuToggleReservation.cloneNode(true);
      mobileMenuToggleReservation.parentNode.replaceChild(newButton, mobileMenuToggleReservation);
      
      newButton.addEventListener('click', function(e) {
        e.preventDefault();
        e.stopPropagation();
        console.log('Mobile menu toggle clicked');
        
        // Mobile navigation for regular users
        if (mobileNav) {
          if (mobileNav.classList.contains('active')) {
            mobileNav.classList.remove('active');
            if (mobileNavOverlay) mobileNavOverlay.classList.remove('active');
            document.body.style.overflow = '';
            console.log('Mobile nav closed');
          } else {
            mobileNav.classList.add('active');
            if (mobileNavOverlay) mobileNavOverlay.classList.add('active');
            document.body.style.overflow = 'hidden';
            console.log('Mobile nav opened');
          }
        }
        
        // Staff sidebar toggle
        if (sidebar && !mobileNav) {
          if (sidebar.classList.contains('mobile-open')) {
            sidebar.classList.remove('mobile-open');
            if (sidebarOverlay) sidebarOverlay.classList.remove('active');
            document.body.style.overflow = '';
            console.log('Sidebar closed');
          } else {
            sidebar.classList.add('mobile-open');
            if (sidebarOverlay) sidebarOverlay.classList.add('active');
            document.body.style.overflow = 'hidden';
            console.log('Sidebar opened');
          }
        }
      });
    } else {
      console.warn('Mobile menu toggle reservation button not found');
    }
  }
  
  // Initialize mobile menu toggle - try multiple times to ensure DOM is ready
  initMobileMenuToggleReservation();
  setTimeout(initMobileMenuToggleReservation, 100);
  setTimeout(initMobileMenuToggleReservation, 500);
  
  // WebSocket connection for booking status updates (auto-refresh when QR is scanned)
  (function initBookingStatusWS() {
    var bookingWS = null;
    var reconnectAttempts = 0;
    var maxReconnectAttempts = 5;
    var reconnectDelay = 3000;
    var shouldReconnect = true;
    
    function connect() {
      try {
        const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsPath = `${wsProtocol}//${window.location.host}/ws/booking-status/`;
        bookingWS = new WebSocket(wsPath);
        
        bookingWS.onopen = function() {
          console.log('âœ… Booking status WebSocket connected');
          reconnectAttempts = 0;
          // Send heartbeat periodically
          setInterval(function() {
            if (bookingWS && bookingWS.readyState === WebSocket.OPEN) {
              bookingWS.send(JSON.stringify({type: 'heartbeat'}));
            }
          }, 30000); // Every 30 seconds
        };
        
        bookingWS.onmessage = function(event) {
          try {
            const data = JSON.parse(event.data);
            console.log('ðŸ“¨ Booking status update received:', data);
            
            if (data.type === 'booking_status_update') {
              if (data.status === 'confirmed') {
                console.log('âœ… Booking confirmed via QR scan! Refreshing page...');
                
                // Show notification if possible
                if ('Notification' in window && Notification.permission === 'granted') {
                  new Notification('Booking Approved!', {
                    body: data.message || 'Your reservation has been approved!',
                    icon: '/static/favicon.svg'
                  });
                }
                
                // Hard refresh - redirect to home page with cache-busting parameter
                // Use a small delay to ensure the backend has processed the update
                setTimeout(function() {
                  // Add timestamp to force hard refresh (bypass cache)
                  const timestamp = new Date().getTime();
                  window.location.replace('/?_refresh=' + timestamp);
                }, 500);
              }
            } else if (data.type === 'heartbeat_ack') {
              // Heartbeat acknowledged, connection is alive
              console.debug('ðŸ’“ Booking status WebSocket heartbeat acknowledged');
            }
          } catch (error) {
            console.error('âŒ Error parsing booking status message:', error);
          }
        };
        
        bookingWS.onerror = function(error) {
          console.error('âŒ Booking status WebSocket error:', error);
          if (reconnectAttempts >= maxReconnectAttempts) {
            shouldReconnect = false;
          }
        };
        
        bookingWS.onclose = function() {
          console.log('âŒ Booking status WebSocket closed');
          if (shouldReconnect && reconnectAttempts < maxReconnectAttempts) {
            reconnectAttempts++;
            setTimeout(function() {
              if (shouldReconnect) {
                console.log(`ðŸ”„ Reconnecting booking status WebSocket (attempt ${reconnectAttempts})...`);
                connect();
              }
            }, reconnectDelay);
          }
        };
      } catch (error) {
        console.error('âŒ Error creating booking status WebSocket:', error);
        // Silently fail - polling will still work
      }
    }
    
    // Connect when page loads
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', connect);
    } else {
      connect();
    }
    
    // Cleanup on page unload
    window.addEventListener('beforeunload', function() {
      shouldReconnect = false;
      if (bookingWS) {
        bookingWS.close();
      }
    });
  })();
});
</script>
<script src="{% static 'js/reserve_pc.js' %}"></script>
{% endblock %}